// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: debates.sql

package models

import (
	"context"
	"database/sql"
	"time"
)

const addTeamMember = `-- name: AddTeamMember :one
INSERT INTO TeamMembers (TeamID, StudentID)
VALUES ($1, $2)
RETURNING TeamID, StudentID
`

type AddTeamMemberParams struct {
	Teamid    int32 `json:"teamid"`
	Studentid int32 `json:"studentid"`
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) (Teammember, error) {
	row := q.db.QueryRowContext(ctx, addTeamMember, arg.Teamid, arg.Studentid)
	var i Teammember
	err := row.Scan(&i.Teamid, &i.Studentid)
	return i, err
}

const assignJudgeToDebate = `-- name: AssignJudgeToDebate :exec
INSERT INTO JudgeAssignments (TournamentID, JudgeID, DebateID, RoundNumber, IsElimination, IsHeadJudge)
VALUES ($1, $2, $3, $4, $5, $6)
`

type AssignJudgeToDebateParams struct {
	Tournamentid  int32 `json:"tournamentid"`
	Judgeid       int32 `json:"judgeid"`
	Debateid      int32 `json:"debateid"`
	Roundnumber   int32 `json:"roundnumber"`
	Iselimination bool  `json:"iselimination"`
	Isheadjudge   bool  `json:"isheadjudge"`
}

func (q *Queries) AssignJudgeToDebate(ctx context.Context, arg AssignJudgeToDebateParams) error {
	_, err := q.db.ExecContext(ctx, assignJudgeToDebate,
		arg.Tournamentid,
		arg.Judgeid,
		arg.Debateid,
		arg.Roundnumber,
		arg.Iselimination,
		arg.Isheadjudge,
	)
	return err
}

const assignRoomToDebate = `-- name: AssignRoomToDebate :exec
UPDATE Debates
SET RoomID = $2
WHERE DebateID = $1
`

type AssignRoomToDebateParams struct {
	Debateid int32 `json:"debateid"`
	Roomid   int32 `json:"roomid"`
}

func (q *Queries) AssignRoomToDebate(ctx context.Context, arg AssignRoomToDebateParams) error {
	_, err := q.db.ExecContext(ctx, assignRoomToDebate, arg.Debateid, arg.Roomid)
	return err
}

const checkExistingTeamMembership = `-- name: CheckExistingTeamMembership :one
SELECT COUNT(*) > 0 AS has_team
FROM TeamMembers tm
JOIN Teams t ON tm.TeamID = t.TeamID
WHERE t.TournamentID = $1 AND tm.StudentID = $2
`

type CheckExistingTeamMembershipParams struct {
	Tournamentid int32 `json:"tournamentid"`
	Studentid    int32 `json:"studentid"`
}

func (q *Queries) CheckExistingTeamMembership(ctx context.Context, arg CheckExistingTeamMembershipParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkExistingTeamMembership, arg.Tournamentid, arg.Studentid)
	var has_team bool
	err := row.Scan(&has_team)
	return has_team, err
}

const countJudgeDebates = `-- name: CountJudgeDebates :one
SELECT
    COUNT(DISTINCT d.DebateID) as DebateCount
FROM
    JudgeAssignments ja
JOIN
    Debates d ON ja.DebateID = d.DebateID
WHERE
    ja.JudgeID = $1 AND
    d.TournamentID = $2 AND
    d.IsEliminationRound = $3
`

type CountJudgeDebatesParams struct {
	Judgeid            int32 `json:"judgeid"`
	Tournamentid       int32 `json:"tournamentid"`
	Iseliminationround bool  `json:"iseliminationround"`
}

func (q *Queries) CountJudgeDebates(ctx context.Context, arg CountJudgeDebatesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJudgeDebates, arg.Judgeid, arg.Tournamentid, arg.Iseliminationround)
	var debatecount int64
	err := row.Scan(&debatecount)
	return debatecount, err
}

const createBallot = `-- name: CreateBallot :one
INSERT INTO ballots (
    debateid,
    judgeid,
    recordingstatus,
    verdict
) VALUES (
    $1, $2, $3, $4
)
RETURNING ballotid, debateid, judgeid, team1totalscore, team1feedback, team2totalscore, team2feedback, recordingstatus, verdict, last_updated_by, last_updated_at, head_judge_submitted
`

type CreateBallotParams struct {
	Debateid        int32  `json:"debateid"`
	Judgeid         int32  `json:"judgeid"`
	Recordingstatus string `json:"recordingstatus"`
	Verdict         string `json:"verdict"`
}

func (q *Queries) CreateBallot(ctx context.Context, arg CreateBallotParams) (Ballot, error) {
	row := q.db.QueryRowContext(ctx, createBallot,
		arg.Debateid,
		arg.Judgeid,
		arg.Recordingstatus,
		arg.Verdict,
	)
	var i Ballot
	err := row.Scan(
		&i.Ballotid,
		&i.Debateid,
		&i.Judgeid,
		&i.Team1totalscore,
		&i.Team1feedback,
		&i.Team2totalscore,
		&i.Team2feedback,
		&i.Recordingstatus,
		&i.Verdict,
		&i.LastUpdatedBy,
		&i.LastUpdatedAt,
		&i.HeadJudgeSubmitted,
	)
	return i, err
}

const createDebate = `-- name: CreateDebate :one
INSERT INTO Debates (TournamentID, RoundID, RoundNumber, IsEliminationRound, Team1ID, Team2ID, RoomID, StartTime)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING DebateID
`

type CreateDebateParams struct {
	Tournamentid       int32     `json:"tournamentid"`
	Roundid            int32     `json:"roundid"`
	Roundnumber        int32     `json:"roundnumber"`
	Iseliminationround bool      `json:"iseliminationround"`
	Team1id            int32     `json:"team1id"`
	Team2id            int32     `json:"team2id"`
	Roomid             int32     `json:"roomid"`
	Starttime          time.Time `json:"starttime"`
}

func (q *Queries) CreateDebate(ctx context.Context, arg CreateDebateParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createDebate,
		arg.Tournamentid,
		arg.Roundid,
		arg.Roundnumber,
		arg.Iseliminationround,
		arg.Team1id,
		arg.Team2id,
		arg.Roomid,
		arg.Starttime,
	)
	var debateid int32
	err := row.Scan(&debateid)
	return debateid, err
}

const createInitialSpeakerScores = `-- name: CreateInitialSpeakerScores :exec
WITH ballot_info AS (
    SELECT b.BallotID, d.Team1ID, d.Team2ID
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.DebateID = $1
    ORDER BY b.BallotID  -- Added explicit ordering
),
team_speakers AS (
    SELECT tm.StudentID as SpeakerID, t.TeamID,
           CASE
               WHEN t.TeamID = bi.Team1ID THEN 1
               WHEN t.TeamID = bi.Team2ID THEN 2
           END as TeamNumber
    FROM TeamMembers tm
    JOIN Teams t ON tm.TeamID = t.TeamID
    JOIN ballot_info bi ON t.TeamID IN (bi.Team1ID, bi.Team2ID)
)
INSERT INTO SpeakerScores (BallotID, SpeakerID, SpeakerRank, SpeakerPoints)
SELECT bi.BallotID, ts.SpeakerID,
       ROW_NUMBER() OVER (PARTITION BY bi.BallotID, ts.TeamNumber ORDER BY ts.SpeakerID) as SpeakerRank,
       0 as SpeakerPoints
FROM ballot_info bi
JOIN team_speakers ts ON (ts.TeamNumber = 1 AND bi.Team1ID = ts.TeamID)
                      OR (ts.TeamNumber = 2 AND bi.Team2ID = ts.TeamID)
`

func (q *Queries) CreateInitialSpeakerScores(ctx context.Context, debateid int32) error {
	_, err := q.db.ExecContext(ctx, createInitialSpeakerScores, debateid)
	return err
}

const createJudgeFeedback = `-- name: CreateJudgeFeedback :one
INSERT INTO JudgeFeedback (
    JudgeID, StudentID, DebateID,
    ClarityRating, ConstructivenessRating, TimelinessRating,
    FairnessRating, EngagementRating, TextFeedback
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING feedbackid, judgeid, studentid, debateid, clarityrating, constructivenessrating, timelinessrating, fairnessrating, engagementrating, averagerating, textfeedback, isread, createdat
`

type CreateJudgeFeedbackParams struct {
	Judgeid                sql.NullInt32   `json:"judgeid"`
	Studentid              sql.NullInt32   `json:"studentid"`
	Debateid               sql.NullInt32   `json:"debateid"`
	Clarityrating          sql.NullFloat64 `json:"clarityrating"`
	Constructivenessrating sql.NullFloat64 `json:"constructivenessrating"`
	Timelinessrating       sql.NullFloat64 `json:"timelinessrating"`
	Fairnessrating         sql.NullFloat64 `json:"fairnessrating"`
	Engagementrating       sql.NullFloat64 `json:"engagementrating"`
	Textfeedback           sql.NullString  `json:"textfeedback"`
}

func (q *Queries) CreateJudgeFeedback(ctx context.Context, arg CreateJudgeFeedbackParams) (Judgefeedback, error) {
	row := q.db.QueryRowContext(ctx, createJudgeFeedback,
		arg.Judgeid,
		arg.Studentid,
		arg.Debateid,
		arg.Clarityrating,
		arg.Constructivenessrating,
		arg.Timelinessrating,
		arg.Fairnessrating,
		arg.Engagementrating,
		arg.Textfeedback,
	)
	var i Judgefeedback
	err := row.Scan(
		&i.Feedbackid,
		&i.Judgeid,
		&i.Studentid,
		&i.Debateid,
		&i.Clarityrating,
		&i.Constructivenessrating,
		&i.Timelinessrating,
		&i.Fairnessrating,
		&i.Engagementrating,
		&i.Averagerating,
		&i.Textfeedback,
		&i.Isread,
		&i.Createdat,
	)
	return i, err
}

const createPairingHistory = `-- name: CreatePairingHistory :exec
INSERT INTO PairingHistory (TournamentID, Team1ID, Team2ID, RoundNumber, IsElimination)
VALUES ($1, $2, $3, $4, $5)
`

type CreatePairingHistoryParams struct {
	Tournamentid  int32 `json:"tournamentid"`
	Team1id       int32 `json:"team1id"`
	Team2id       int32 `json:"team2id"`
	Roundnumber   int32 `json:"roundnumber"`
	Iselimination bool  `json:"iselimination"`
}

func (q *Queries) CreatePairingHistory(ctx context.Context, arg CreatePairingHistoryParams) error {
	_, err := q.db.ExecContext(ctx, createPairingHistory,
		arg.Tournamentid,
		arg.Team1id,
		arg.Team2id,
		arg.Roundnumber,
		arg.Iselimination,
	)
	return err
}

const createRoom = `-- name: CreateRoom :one
INSERT INTO Rooms (RoomName, Location, Capacity, TournamentID)
VALUES ($1, $2, $3, $4)
RETURNING roomid, roomname, location, capacity, tournamentid
`

type CreateRoomParams struct {
	Roomname     string        `json:"roomname"`
	Location     string        `json:"location"`
	Capacity     int32         `json:"capacity"`
	Tournamentid sql.NullInt32 `json:"tournamentid"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (Room, error) {
	row := q.db.QueryRowContext(ctx, createRoom,
		arg.Roomname,
		arg.Location,
		arg.Capacity,
		arg.Tournamentid,
	)
	var i Room
	err := row.Scan(
		&i.Roomid,
		&i.Roomname,
		&i.Location,
		&i.Capacity,
		&i.Tournamentid,
	)
	return i, err
}

const createSpeakerScore = `-- name: CreateSpeakerScore :exec
INSERT INTO SpeakerScores (BallotID, SpeakerID, SpeakerRank, SpeakerPoints, Feedback)
VALUES ($1, $2, $3, $4, $5)
`

type CreateSpeakerScoreParams struct {
	Ballotid      int32          `json:"ballotid"`
	Speakerid     int32          `json:"speakerid"`
	Speakerrank   int32          `json:"speakerrank"`
	Speakerpoints string         `json:"speakerpoints"`
	Feedback      sql.NullString `json:"feedback"`
}

func (q *Queries) CreateSpeakerScore(ctx context.Context, arg CreateSpeakerScoreParams) error {
	_, err := q.db.ExecContext(ctx, createSpeakerScore,
		arg.Ballotid,
		arg.Speakerid,
		arg.Speakerrank,
		arg.Speakerpoints,
		arg.Feedback,
	)
	return err
}

const createTeam = `-- name: CreateTeam :one
INSERT INTO Teams (Name, TournamentID)
VALUES ($1, $2)
RETURNING TeamID, Name, TournamentID
`

type CreateTeamParams struct {
	Name         string `json:"name"`
	Tournamentid int32  `json:"tournamentid"`
}

type CreateTeamRow struct {
	Teamid       int32  `json:"teamid"`
	Name         string `json:"name"`
	Tournamentid int32  `json:"tournamentid"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (CreateTeamRow, error) {
	row := q.db.QueryRowContext(ctx, createTeam, arg.Name, arg.Tournamentid)
	var i CreateTeamRow
	err := row.Scan(&i.Teamid, &i.Name, &i.Tournamentid)
	return i, err
}

const deleteDebatesForTournament = `-- name: DeleteDebatesForTournament :exec
DELETE FROM Debates
WHERE TournamentID = $1
`

func (q *Queries) DeleteDebatesForTournament(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deleteDebatesForTournament, tournamentid)
	return err
}

const deleteJudgeAssignmentsForTournament = `-- name: DeleteJudgeAssignmentsForTournament :exec
DELETE FROM JudgeAssignments
WHERE TournamentID = $1
`

func (q *Queries) DeleteJudgeAssignmentsForTournament(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deleteJudgeAssignmentsForTournament, tournamentid)
	return err
}

const deletePairingHistoryForTournament = `-- name: DeletePairingHistoryForTournament :exec
DELETE FROM PairingHistory
WHERE TournamentID = $1
`

func (q *Queries) DeletePairingHistoryForTournament(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deletePairingHistoryForTournament, tournamentid)
	return err
}

const deletePairingsForTournament = `-- name: DeletePairingsForTournament :exec
DELETE FROM Debates
WHERE TournamentID = $1
`

func (q *Queries) DeletePairingsForTournament(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deletePairingsForTournament, tournamentid)
	return err
}

const deleteRoomsForTournament = `-- name: DeleteRoomsForTournament :exec
DELETE FROM Rooms
WHERE TournamentID = $1
`

func (q *Queries) DeleteRoomsForTournament(ctx context.Context, tournamentid sql.NullInt32) error {
	_, err := q.db.ExecContext(ctx, deleteRoomsForTournament, tournamentid)
	return err
}

const deleteRoundsForTournament = `-- name: DeleteRoundsForTournament :exec
DELETE FROM Rounds
WHERE TournamentID = $1
`

func (q *Queries) DeleteRoundsForTournament(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deleteRoundsForTournament, tournamentid)
	return err
}

const deleteSpeakerScoresByBallot = `-- name: DeleteSpeakerScoresByBallot :exec
DELETE FROM SpeakerScores
WHERE BallotID = $1
`

func (q *Queries) DeleteSpeakerScoresByBallot(ctx context.Context, ballotid int32) error {
	_, err := q.db.ExecContext(ctx, deleteSpeakerScoresByBallot, ballotid)
	return err
}

const deleteSpeakerScoresByBallotAndTeam = `-- name: DeleteSpeakerScoresByBallotAndTeam :exec
DELETE FROM SpeakerScores
WHERE BallotID = $1
  AND SpeakerID IN (
    SELECT tm.StudentID
    FROM TeamMembers tm
    WHERE tm.TeamID = $2
)
`

type DeleteSpeakerScoresByBallotAndTeamParams struct {
	Ballotid int32 `json:"ballotid"`
	Teamid   int32 `json:"teamid"`
}

func (q *Queries) DeleteSpeakerScoresByBallotAndTeam(ctx context.Context, arg DeleteSpeakerScoresByBallotAndTeamParams) error {
	_, err := q.db.ExecContext(ctx, deleteSpeakerScoresByBallotAndTeam, arg.Ballotid, arg.Teamid)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
WITH debate_check AS (
    SELECT 1
    FROM Debates
    WHERE Team1ID = $1 OR Team2ID = $1
    LIMIT 1
)
DELETE FROM Teams
WHERE TeamID = $1 AND NOT EXISTS (SELECT 1 FROM debate_check)
`

func (q *Queries) DeleteTeam(ctx context.Context, teamid int32) error {
	_, err := q.db.ExecContext(ctx, deleteTeam, teamid)
	return err
}

const deleteTeamMembers = `-- name: DeleteTeamMembers :exec
DELETE FROM TeamMembers
WHERE TeamID = $1
`

func (q *Queries) DeleteTeamMembers(ctx context.Context, teamid int32) error {
	_, err := q.db.ExecContext(ctx, deleteTeamMembers, teamid)
	return err
}

const getAvailableJudges = `-- name: GetAvailableJudges :many
SELECT DISTINCT u.UserID, u.Name, u.Email, v.iDebateVolunteerID
FROM Users u
         JOIN Volunteers v ON u.UserID = v.UserID
         JOIN TournamentInvitations ti ON ti.InviteeID = v.iDebateVolunteerID
WHERE ti.TournamentID = $1
  AND ti.Status = 'accepted'
  AND ti.InviteeRole = 'volunteer'
`

type GetAvailableJudgesRow struct {
	Userid             int32          `json:"userid"`
	Name               string         `json:"name"`
	Email              string         `json:"email"`
	Idebatevolunteerid sql.NullString `json:"idebatevolunteerid"`
}

func (q *Queries) GetAvailableJudges(ctx context.Context, tournamentid int32) ([]GetAvailableJudgesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableJudges, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAvailableJudgesRow{}
	for rows.Next() {
		var i GetAvailableJudgesRow
		if err := rows.Scan(
			&i.Userid,
			&i.Name,
			&i.Email,
			&i.Idebatevolunteerid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBallotByID = `-- name: GetBallotByID :one
SELECT b.BallotID, d.DebateID, d.RoundNumber, d.IsEliminationRound,
       d.RoomID, r.roomname AS RoomName, b.JudgeID, u.Name AS JudgeName,
       d.Team1ID, t1.Name AS Team1Name, d.Team2ID, t2.Name AS Team2Name,
       b.Team1TotalScore, b.Team2TotalScore, b.RecordingStatus, b.Verdict,
       b.Team1Feedback, b.Team2Feedback, b.last_updated_by, b.last_updated_at,
       b.head_judge_submitted
FROM Ballots b
JOIN Debates d ON b.DebateID = d.DebateID
LEFT JOIN Rooms r ON d.RoomID = r.RoomID
JOIN Users u ON b.JudgeID = u.UserID
JOIN Teams t1 ON d.Team1ID = t1.TeamID
JOIN Teams t2 ON d.Team2ID = t2.TeamID
WHERE b.BallotID = $1
`

type GetBallotByIDRow struct {
	Ballotid           int32          `json:"ballotid"`
	Debateid           int32          `json:"debateid"`
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Roomid             int32          `json:"roomid"`
	Roomname           sql.NullString `json:"roomname"`
	Judgeid            int32          `json:"judgeid"`
	Judgename          string         `json:"judgename"`
	Team1id            int32          `json:"team1id"`
	Team1name          string         `json:"team1name"`
	Team2id            int32          `json:"team2id"`
	Team2name          string         `json:"team2name"`
	Team1totalscore    sql.NullString `json:"team1totalscore"`
	Team2totalscore    sql.NullString `json:"team2totalscore"`
	Recordingstatus    string         `json:"recordingstatus"`
	Verdict            string         `json:"verdict"`
	Team1feedback      sql.NullString `json:"team1feedback"`
	Team2feedback      sql.NullString `json:"team2feedback"`
	LastUpdatedBy      sql.NullInt32  `json:"last_updated_by"`
	LastUpdatedAt      sql.NullTime   `json:"last_updated_at"`
	HeadJudgeSubmitted sql.NullBool   `json:"head_judge_submitted"`
}

func (q *Queries) GetBallotByID(ctx context.Context, ballotid int32) (GetBallotByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBallotByID, ballotid)
	var i GetBallotByIDRow
	err := row.Scan(
		&i.Ballotid,
		&i.Debateid,
		&i.Roundnumber,
		&i.Iseliminationround,
		&i.Roomid,
		&i.Roomname,
		&i.Judgeid,
		&i.Judgename,
		&i.Team1id,
		&i.Team1name,
		&i.Team2id,
		&i.Team2name,
		&i.Team1totalscore,
		&i.Team2totalscore,
		&i.Recordingstatus,
		&i.Verdict,
		&i.Team1feedback,
		&i.Team2feedback,
		&i.LastUpdatedBy,
		&i.LastUpdatedAt,
		&i.HeadJudgeSubmitted,
	)
	return i, err
}

const getBallotByJudgeID = `-- name: GetBallotByJudgeID :one
SELECT b.BallotID, d.DebateID, d.RoundNumber, d.IsEliminationRound,
       d.RoomID, r.roomname AS RoomName, b.JudgeID, u.Name AS JudgeName,
       d.Team1ID, t1.Name AS Team1Name, d.Team2ID, t2.Name AS Team2Name,
       b.Team1TotalScore, b.Team2TotalScore, b.RecordingStatus, b.Verdict,
       b.Team1Feedback, b.Team2Feedback, b.last_updated_by, b.last_updated_at,
       b.head_judge_submitted
FROM Ballots b
JOIN Debates d ON b.DebateID = d.DebateID
LEFT JOIN Rooms r ON d.RoomID = r.RoomID
JOIN Users u ON b.JudgeID = u.UserID
JOIN Teams t1 ON d.Team1ID = t1.TeamID
JOIN Teams t2 ON d.Team2ID = t2.TeamID
WHERE b.JudgeID = $1 AND d.TournamentID = $2
ORDER BY d.RoundNumber DESC
LIMIT 1
`

type GetBallotByJudgeIDParams struct {
	Judgeid      int32 `json:"judgeid"`
	Tournamentid int32 `json:"tournamentid"`
}

type GetBallotByJudgeIDRow struct {
	Ballotid           int32          `json:"ballotid"`
	Debateid           int32          `json:"debateid"`
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Roomid             int32          `json:"roomid"`
	Roomname           sql.NullString `json:"roomname"`
	Judgeid            int32          `json:"judgeid"`
	Judgename          string         `json:"judgename"`
	Team1id            int32          `json:"team1id"`
	Team1name          string         `json:"team1name"`
	Team2id            int32          `json:"team2id"`
	Team2name          string         `json:"team2name"`
	Team1totalscore    sql.NullString `json:"team1totalscore"`
	Team2totalscore    sql.NullString `json:"team2totalscore"`
	Recordingstatus    string         `json:"recordingstatus"`
	Verdict            string         `json:"verdict"`
	Team1feedback      sql.NullString `json:"team1feedback"`
	Team2feedback      sql.NullString `json:"team2feedback"`
	LastUpdatedBy      sql.NullInt32  `json:"last_updated_by"`
	LastUpdatedAt      sql.NullTime   `json:"last_updated_at"`
	HeadJudgeSubmitted sql.NullBool   `json:"head_judge_submitted"`
}

func (q *Queries) GetBallotByJudgeID(ctx context.Context, arg GetBallotByJudgeIDParams) (GetBallotByJudgeIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBallotByJudgeID, arg.Judgeid, arg.Tournamentid)
	var i GetBallotByJudgeIDRow
	err := row.Scan(
		&i.Ballotid,
		&i.Debateid,
		&i.Roundnumber,
		&i.Iseliminationround,
		&i.Roomid,
		&i.Roomname,
		&i.Judgeid,
		&i.Judgename,
		&i.Team1id,
		&i.Team1name,
		&i.Team2id,
		&i.Team2name,
		&i.Team1totalscore,
		&i.Team2totalscore,
		&i.Recordingstatus,
		&i.Verdict,
		&i.Team1feedback,
		&i.Team2feedback,
		&i.LastUpdatedBy,
		&i.LastUpdatedAt,
		&i.HeadJudgeSubmitted,
	)
	return i, err
}

const getBallotsByDebateID = `-- name: GetBallotsByDebateID :many
SELECT ballotid, debateid, judgeid, team1totalscore, team1feedback, team2totalscore, team2feedback, recordingstatus, verdict, last_updated_by, last_updated_at, head_judge_submitted FROM Ballots
WHERE DebateID = $1
`

func (q *Queries) GetBallotsByDebateID(ctx context.Context, debateid int32) ([]Ballot, error) {
	rows, err := q.db.QueryContext(ctx, getBallotsByDebateID, debateid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Ballot{}
	for rows.Next() {
		var i Ballot
		if err := rows.Scan(
			&i.Ballotid,
			&i.Debateid,
			&i.Judgeid,
			&i.Team1totalscore,
			&i.Team1feedback,
			&i.Team2totalscore,
			&i.Team2feedback,
			&i.Recordingstatus,
			&i.Verdict,
			&i.LastUpdatedBy,
			&i.LastUpdatedAt,
			&i.HeadJudgeSubmitted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBallotsByTournamentAndRound = `-- name: GetBallotsByTournamentAndRound :many
SELECT b.BallotID, d.RoundNumber, d.IsEliminationRound, r.RoomName,
       u.Name AS HeadJudgeName, b.RecordingStatus, b.Verdict,
       t1.TeamID as Team1ID, t1.Name as Team1Name,
       t2.TeamID as Team2ID, t2.Name as Team2Name
FROM Ballots b
JOIN Debates d ON b.DebateID = d.DebateID
JOIN Rooms r ON d.RoomID = r.RoomID
JOIN Users u ON b.JudgeID = u.UserID
JOIN Teams t1 ON d.Team1ID = t1.TeamID
JOIN Teams t2 ON d.Team2ID = t2.TeamID
WHERE d.TournamentID = $1 AND d.RoundNumber = $2 AND d.IsEliminationRound = $3
`

type GetBallotsByTournamentAndRoundParams struct {
	Tournamentid       int32 `json:"tournamentid"`
	Roundnumber        int32 `json:"roundnumber"`
	Iseliminationround bool  `json:"iseliminationround"`
}

type GetBallotsByTournamentAndRoundRow struct {
	Ballotid           int32  `json:"ballotid"`
	Roundnumber        int32  `json:"roundnumber"`
	Iseliminationround bool   `json:"iseliminationround"`
	Roomname           string `json:"roomname"`
	Headjudgename      string `json:"headjudgename"`
	Recordingstatus    string `json:"recordingstatus"`
	Verdict            string `json:"verdict"`
	Team1id            int32  `json:"team1id"`
	Team1name          string `json:"team1name"`
	Team2id            int32  `json:"team2id"`
	Team2name          string `json:"team2name"`
}

func (q *Queries) GetBallotsByTournamentAndRound(ctx context.Context, arg GetBallotsByTournamentAndRoundParams) ([]GetBallotsByTournamentAndRoundRow, error) {
	rows, err := q.db.QueryContext(ctx, getBallotsByTournamentAndRound, arg.Tournamentid, arg.Roundnumber, arg.Iseliminationround)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBallotsByTournamentAndRoundRow{}
	for rows.Next() {
		var i GetBallotsByTournamentAndRoundRow
		if err := rows.Scan(
			&i.Ballotid,
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Roomname,
			&i.Headjudgename,
			&i.Recordingstatus,
			&i.Verdict,
			&i.Team1id,
			&i.Team1name,
			&i.Team2id,
			&i.Team2name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDebateByBallotID = `-- name: GetDebateByBallotID :one
SELECT d.DebateID, d.Team1ID, d.Team2ID, d.IsEliminationRound, d.TournamentID
FROM Debates d
JOIN Ballots b ON d.DebateID = b.DebateID
WHERE b.BallotID = $1
`

type GetDebateByBallotIDRow struct {
	Debateid           int32 `json:"debateid"`
	Team1id            int32 `json:"team1id"`
	Team2id            int32 `json:"team2id"`
	Iseliminationround bool  `json:"iseliminationround"`
	Tournamentid       int32 `json:"tournamentid"`
}

func (q *Queries) GetDebateByBallotID(ctx context.Context, ballotid int32) (GetDebateByBallotIDRow, error) {
	row := q.db.QueryRowContext(ctx, getDebateByBallotID, ballotid)
	var i GetDebateByBallotIDRow
	err := row.Scan(
		&i.Debateid,
		&i.Team1id,
		&i.Team2id,
		&i.Iseliminationround,
		&i.Tournamentid,
	)
	return i, err
}

const getDebateByID = `-- name: GetDebateByID :one
SELECT debateid, roundid, roundnumber, iseliminationround, tournamentid, team1id, team2id, starttime, endtime, roomid, status FROM Debates
WHERE DebateID = $1
`

func (q *Queries) GetDebateByID(ctx context.Context, debateid int32) (Debate, error) {
	row := q.db.QueryRowContext(ctx, getDebateByID, debateid)
	var i Debate
	err := row.Scan(
		&i.Debateid,
		&i.Roundid,
		&i.Roundnumber,
		&i.Iseliminationround,
		&i.Tournamentid,
		&i.Team1id,
		&i.Team2id,
		&i.Starttime,
		&i.Endtime,
		&i.Roomid,
		&i.Status,
	)
	return i, err
}

const getDebateByRoomAndRound = `-- name: GetDebateByRoomAndRound :one
SELECT debateid, roundid, roundnumber, iseliminationround, tournamentid, team1id, team2id, starttime, endtime, roomid, status
FROM Debates
WHERE TournamentID = $1 AND RoomID = $2 AND RoundNumber = $3 AND IsEliminationRound = $4
LIMIT 1
`

type GetDebateByRoomAndRoundParams struct {
	Tournamentid       int32 `json:"tournamentid"`
	Roomid             int32 `json:"roomid"`
	Roundnumber        int32 `json:"roundnumber"`
	Iseliminationround bool  `json:"iseliminationround"`
}

func (q *Queries) GetDebateByRoomAndRound(ctx context.Context, arg GetDebateByRoomAndRoundParams) (Debate, error) {
	row := q.db.QueryRowContext(ctx, getDebateByRoomAndRound,
		arg.Tournamentid,
		arg.Roomid,
		arg.Roundnumber,
		arg.Iseliminationround,
	)
	var i Debate
	err := row.Scan(
		&i.Debateid,
		&i.Roundid,
		&i.Roundnumber,
		&i.Iseliminationround,
		&i.Tournamentid,
		&i.Team1id,
		&i.Team2id,
		&i.Starttime,
		&i.Endtime,
		&i.Roomid,
		&i.Status,
	)
	return i, err
}

const getDebatesByRoomAndTournament = `-- name: GetDebatesByRoomAndTournament :many
SELECT debateid, roundid, roundnumber, iseliminationround, tournamentid, team1id, team2id, starttime, endtime, roomid, status
FROM Debates
WHERE TournamentID = $1 AND RoomID = $2 AND IsEliminationRound = $3
`

type GetDebatesByRoomAndTournamentParams struct {
	Tournamentid       int32 `json:"tournamentid"`
	Roomid             int32 `json:"roomid"`
	Iseliminationround bool  `json:"iseliminationround"`
}

func (q *Queries) GetDebatesByRoomAndTournament(ctx context.Context, arg GetDebatesByRoomAndTournamentParams) ([]Debate, error) {
	rows, err := q.db.QueryContext(ctx, getDebatesByRoomAndTournament, arg.Tournamentid, arg.Roomid, arg.Iseliminationround)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Debate{}
	for rows.Next() {
		var i Debate
		if err := rows.Scan(
			&i.Debateid,
			&i.Roundid,
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Tournamentid,
			&i.Team1id,
			&i.Team2id,
			&i.Starttime,
			&i.Endtime,
			&i.Roomid,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDebatesByTeam = `-- name: GetDebatesByTeam :many
SELECT debateid, roundid, roundnumber, iseliminationround, tournamentid, team1id, team2id, starttime, endtime, roomid, status FROM Debates
WHERE Team1ID = $1 OR Team2ID = $1
`

func (q *Queries) GetDebatesByTeam(ctx context.Context, team1id int32) ([]Debate, error) {
	rows, err := q.db.QueryContext(ctx, getDebatesByTeam, team1id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Debate{}
	for rows.Next() {
		var i Debate
		if err := rows.Scan(
			&i.Debateid,
			&i.Roundid,
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Tournamentid,
			&i.Team1id,
			&i.Team2id,
			&i.Starttime,
			&i.Endtime,
			&i.Roomid,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEliminationRoundTeams = `-- name: GetEliminationRoundTeams :many
SELECT
    CASE
        WHEN b.Verdict = t1.Name THEN d.Team1ID
        WHEN b.Verdict = t2.Name THEN d.Team2ID
    END AS TeamID,
    CASE
        WHEN b.Verdict = t1.Name THEN t1.Name
        WHEN b.Verdict = t2.Name THEN t2.Name
    END AS TeamName,
    d.TournamentID,
    CASE
        WHEN b.Verdict = t1.Name THEN b.Team1TotalScore
        WHEN b.Verdict = t2.Name THEN b.Team2TotalScore
    END AS TotalScore
FROM
    Debates d
JOIN
    Ballots b ON d.DebateID = b.DebateID
JOIN
    Teams t1 ON d.Team1ID = t1.TeamID
JOIN
    Teams t2 ON d.Team2ID = t2.TeamID
WHERE
    d.TournamentID = $1
    AND d.RoundNumber = $2
    AND d.IsEliminationRound = true
    AND b.RecordingStatus = 'Recorded'
    AND (b.Verdict = t1.Name OR b.Verdict = t2.Name)
ORDER BY
    CASE
        WHEN b.Verdict = t1.Name THEN b.Team1TotalScore
        WHEN b.Verdict = t2.Name THEN b.Team2TotalScore
    END DESC
LIMIT $3
`

type GetEliminationRoundTeamsParams struct {
	Tournamentid int32 `json:"tournamentid"`
	Roundnumber  int32 `json:"roundnumber"`
	Limit        int32 `json:"limit"`
}

type GetEliminationRoundTeamsRow struct {
	Teamid       interface{} `json:"teamid"`
	Teamname     interface{} `json:"teamname"`
	Tournamentid int32       `json:"tournamentid"`
	Totalscore   interface{} `json:"totalscore"`
}

func (q *Queries) GetEliminationRoundTeams(ctx context.Context, arg GetEliminationRoundTeamsParams) ([]GetEliminationRoundTeamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEliminationRoundTeams, arg.Tournamentid, arg.Roundnumber, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEliminationRoundTeamsRow{}
	for rows.Next() {
		var i GetEliminationRoundTeamsRow
		if err := rows.Scan(
			&i.Teamid,
			&i.Teamname,
			&i.Tournamentid,
			&i.Totalscore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJudgeByID = `-- name: GetJudgeByID :one
SELECT u.UserID, u.Name, u.Email
FROM Users u
WHERE u.UserID = $1
`

type GetJudgeByIDRow struct {
	Userid int32  `json:"userid"`
	Name   string `json:"name"`
	Email  string `json:"email"`
}

func (q *Queries) GetJudgeByID(ctx context.Context, userid int32) (GetJudgeByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getJudgeByID, userid)
	var i GetJudgeByIDRow
	err := row.Scan(&i.Userid, &i.Name, &i.Email)
	return i, err
}

const getJudgeDetails = `-- name: GetJudgeDetails :one
SELECT
    u.UserID as JudgeID,
    u.Name,
    v.iDebateVolunteerID
FROM
    Users u
JOIN
    Volunteers v ON u.UserID = v.UserID
WHERE
    u.UserID = $1
`

type GetJudgeDetailsRow struct {
	Judgeid            int32          `json:"judgeid"`
	Name               string         `json:"name"`
	Idebatevolunteerid sql.NullString `json:"idebatevolunteerid"`
}

func (q *Queries) GetJudgeDetails(ctx context.Context, userid int32) (GetJudgeDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getJudgeDetails, userid)
	var i GetJudgeDetailsRow
	err := row.Scan(&i.Judgeid, &i.Name, &i.Idebatevolunteerid)
	return i, err
}

const getJudgeFeedbackCount = `-- name: GetJudgeFeedbackCount :one
SELECT COUNT(*)
FROM JudgeFeedback
WHERE JudgeID = $1
`

func (q *Queries) GetJudgeFeedbackCount(ctx context.Context, judgeid sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getJudgeFeedbackCount, judgeid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getJudgeFeedbackList = `-- name: GetJudgeFeedbackList :many
SELECT
    f.feedbackid, f.judgeid, f.studentid, f.debateid, f.clarityrating, f.constructivenessrating, f.timelinessrating, f.fairnessrating, f.engagementrating, f.averagerating, f.textfeedback, f.isread, f.createdat,
    d.RoundNumber,
    d.IsEliminationRound,
    t.StartDate as TournamentDate,
    b.BallotID as BallotID
FROM JudgeFeedback f
JOIN Debates d ON f.DebateID = d.DebateID
JOIN Tournaments t ON d.TournamentID = t.TournamentID
JOIN Ballots b ON d.DebateID = b.DebateID
WHERE f.JudgeID = $1
ORDER BY f.CreatedAt DESC
LIMIT $2 OFFSET $3
`

type GetJudgeFeedbackListParams struct {
	Judgeid sql.NullInt32 `json:"judgeid"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

type GetJudgeFeedbackListRow struct {
	Feedbackid             int32           `json:"feedbackid"`
	Judgeid                sql.NullInt32   `json:"judgeid"`
	Studentid              sql.NullInt32   `json:"studentid"`
	Debateid               sql.NullInt32   `json:"debateid"`
	Clarityrating          sql.NullFloat64 `json:"clarityrating"`
	Constructivenessrating sql.NullFloat64 `json:"constructivenessrating"`
	Timelinessrating       sql.NullFloat64 `json:"timelinessrating"`
	Fairnessrating         sql.NullFloat64 `json:"fairnessrating"`
	Engagementrating       sql.NullFloat64 `json:"engagementrating"`
	Averagerating          sql.NullFloat64 `json:"averagerating"`
	Textfeedback           sql.NullString  `json:"textfeedback"`
	Isread                 sql.NullBool    `json:"isread"`
	Createdat              sql.NullTime    `json:"createdat"`
	Roundnumber            int32           `json:"roundnumber"`
	Iseliminationround     bool            `json:"iseliminationround"`
	Tournamentdate         time.Time       `json:"tournamentdate"`
	Ballotid               int32           `json:"ballotid"`
}

func (q *Queries) GetJudgeFeedbackList(ctx context.Context, arg GetJudgeFeedbackListParams) ([]GetJudgeFeedbackListRow, error) {
	rows, err := q.db.QueryContext(ctx, getJudgeFeedbackList, arg.Judgeid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJudgeFeedbackListRow{}
	for rows.Next() {
		var i GetJudgeFeedbackListRow
		if err := rows.Scan(
			&i.Feedbackid,
			&i.Judgeid,
			&i.Studentid,
			&i.Debateid,
			&i.Clarityrating,
			&i.Constructivenessrating,
			&i.Timelinessrating,
			&i.Fairnessrating,
			&i.Engagementrating,
			&i.Averagerating,
			&i.Textfeedback,
			&i.Isread,
			&i.Createdat,
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Tournamentdate,
			&i.Ballotid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJudgeRooms = `-- name: GetJudgeRooms :many
SELECT
    d.RoundNumber,
    d.RoomID,
    r.RoomName,
    ja.IsHeadJudge
FROM
    JudgeAssignments ja
        JOIN
    Debates d ON ja.DebateID = d.DebateID
        JOIN
    Rooms r ON d.RoomID = r.RoomID
WHERE
    ja.JudgeID = $1 AND
    d.TournamentID = $2 AND
    d.IsEliminationRound = $3
ORDER BY
    d.RoundNumber
`

type GetJudgeRoomsParams struct {
	Judgeid            int32 `json:"judgeid"`
	Tournamentid       int32 `json:"tournamentid"`
	Iseliminationround bool  `json:"iseliminationround"`
}

type GetJudgeRoomsRow struct {
	Roundnumber int32  `json:"roundnumber"`
	Roomid      int32  `json:"roomid"`
	Roomname    string `json:"roomname"`
	Isheadjudge bool   `json:"isheadjudge"`
}

func (q *Queries) GetJudgeRooms(ctx context.Context, arg GetJudgeRoomsParams) ([]GetJudgeRoomsRow, error) {
	rows, err := q.db.QueryContext(ctx, getJudgeRooms, arg.Judgeid, arg.Tournamentid, arg.Iseliminationround)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJudgeRoomsRow{}
	for rows.Next() {
		var i GetJudgeRoomsRow
		if err := rows.Scan(
			&i.Roundnumber,
			&i.Roomid,
			&i.Roomname,
			&i.Isheadjudge,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJudgesByTournamentAndRound = `-- name: GetJudgesByTournamentAndRound :many
SELECT u.UserID, u.Name, u.Email, ja.IsHeadJudge
FROM Users u
JOIN JudgeAssignments ja ON u.UserID = ja.JudgeID
WHERE ja.TournamentID = $1 AND ja.RoundNumber = $2 AND ja.IsElimination = $3
`

type GetJudgesByTournamentAndRoundParams struct {
	Tournamentid  int32 `json:"tournamentid"`
	Roundnumber   int32 `json:"roundnumber"`
	Iselimination bool  `json:"iselimination"`
}

type GetJudgesByTournamentAndRoundRow struct {
	Userid      int32  `json:"userid"`
	Name        string `json:"name"`
	Email       string `json:"email"`
	Isheadjudge bool   `json:"isheadjudge"`
}

func (q *Queries) GetJudgesByTournamentAndRound(ctx context.Context, arg GetJudgesByTournamentAndRoundParams) ([]GetJudgesByTournamentAndRoundRow, error) {
	rows, err := q.db.QueryContext(ctx, getJudgesByTournamentAndRound, arg.Tournamentid, arg.Roundnumber, arg.Iselimination)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJudgesByTournamentAndRoundRow{}
	for rows.Next() {
		var i GetJudgesByTournamentAndRoundRow
		if err := rows.Scan(
			&i.Userid,
			&i.Name,
			&i.Email,
			&i.Isheadjudge,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJudgesForDebate = `-- name: GetJudgesForDebate :many
SELECT ja.JudgeID, u.Name
FROM JudgeAssignments ja
JOIN Users u ON ja.JudgeID = u.UserID
WHERE ja.DebateID = $1
`

type GetJudgesForDebateRow struct {
	Judgeid int32  `json:"judgeid"`
	Name    string `json:"name"`
}

func (q *Queries) GetJudgesForDebate(ctx context.Context, debateid int32) ([]GetJudgesForDebateRow, error) {
	rows, err := q.db.QueryContext(ctx, getJudgesForDebate, debateid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJudgesForDebateRow{}
	for rows.Next() {
		var i GetJudgesForDebateRow
		if err := rows.Scan(&i.Judgeid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJudgesForTournament = `-- name: GetJudgesForTournament :many
SELECT
    u.UserID as JudgeID,
    u.Name,
    v.iDebateVolunteerID,
    COALESCE(r.RoomName, 'Unassigned') AS RoomName,
    COALESCE(ja.IsHeadJudge, false) AS IsHeadJudge,
    CASE WHEN ja.JudgeID IS NULL THEN false ELSE true END AS IsAssigned
FROM
    Users u
        JOIN
    Volunteers v ON u.UserID = v.UserID
        JOIN
    TournamentInvitations ti ON ti.InviteeID = v.iDebateVolunteerID
        LEFT JOIN
    JudgeAssignments ja ON u.UserID = ja.JudgeID AND ja.TournamentID = $1
        LEFT JOIN
    Debates d ON ja.DebateID = d.DebateID
        LEFT JOIN
    Rooms r ON d.RoomID = r.RoomID
WHERE
    ti.TournamentID = $1
  AND ti.Status = 'accepted'
  AND ti.InviteeRole = 'volunteer'
ORDER BY
    IsAssigned DESC, u.Name
`

type GetJudgesForTournamentRow struct {
	Judgeid            int32          `json:"judgeid"`
	Name               string         `json:"name"`
	Idebatevolunteerid sql.NullString `json:"idebatevolunteerid"`
	Roomname           string         `json:"roomname"`
	Isheadjudge        bool           `json:"isheadjudge"`
	Isassigned         bool           `json:"isassigned"`
}

func (q *Queries) GetJudgesForTournament(ctx context.Context, tournamentid int32) ([]GetJudgesForTournamentRow, error) {
	rows, err := q.db.QueryContext(ctx, getJudgesForTournament, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetJudgesForTournamentRow{}
	for rows.Next() {
		var i GetJudgesForTournamentRow
		if err := rows.Scan(
			&i.Judgeid,
			&i.Name,
			&i.Idebatevolunteerid,
			&i.Roomname,
			&i.Isheadjudge,
			&i.Isassigned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverallSchoolRanking = `-- name: GetOverallSchoolRanking :many
WITH school_ranking AS (
    SELECT
        s.SchoolID,
        s.SchoolName,
        CAST(COALESCE(SUM(ts.TotalScore), 0) AS DECIMAL(10,2)) AS TotalPoints,
        COALESCE(AVG(ts.Rank), 0) AS AverageRank,
        COUNT(DISTINCT tour.TournamentID) as TournamentsParticipated,
        RANK() OVER (ORDER BY COALESCE(SUM(ts.TotalScore), 0) DESC, COALESCE(AVG(ts.Rank), 0) ASC) as CurrentRank,
        COUNT(*) OVER () as TotalSchools,
        MAX(tour.StartDate) as LastTournamentDate
    FROM
        Schools s
        LEFT JOIN Students stu ON s.SchoolID = stu.SchoolID
        LEFT JOIN TeamMembers tm ON stu.StudentID = tm.StudentID
        LEFT JOIN Teams te ON tm.TeamID = te.TeamID
        LEFT JOIN Debates d ON (te.TeamID = d.Team1ID OR te.TeamID = d.Team2ID)
        LEFT JOIN TeamScores ts ON te.TeamID = ts.TeamID AND d.DebateID = ts.DebateID
        LEFT JOIN Tournaments tour ON d.TournamentID = tour.TournamentID
        LEFT JOIN Leagues l ON tour.LeagueID = l.LeagueID
    WHERE
        s.SchoolID = $1 OR s.SchoolID IN (
            SELECT s2.SchoolID
            FROM Schools s2
            LEFT JOIN Students stu2 ON s2.SchoolID = stu2.SchoolID
            LEFT JOIN TeamMembers tm2 ON stu2.StudentID = tm2.StudentID
            LEFT JOIN Teams te2 ON tm2.TeamID = te2.TeamID
            LEFT JOIN Debates d2 ON (te2.TeamID = d2.Team1ID OR te2.TeamID = d2.Team2ID)
            LEFT JOIN TeamScores ts2 ON te2.TeamID = ts2.TeamID AND d2.DebateID = ts2.DebateID
            GROUP BY s2.SchoolID
            ORDER BY COALESCE(SUM(ts2.TotalScore), 0) DESC
            LIMIT 3
        )
    GROUP BY
        s.SchoolID, s.SchoolName
)
SELECT schoolid, schoolname, totalpoints, averagerank, tournamentsparticipated, currentrank, totalschools, lasttournamentdate
FROM school_ranking
ORDER BY CurrentRank
`

type GetOverallSchoolRankingRow struct {
	Schoolid                int32       `json:"schoolid"`
	Schoolname              string      `json:"schoolname"`
	Totalpoints             string      `json:"totalpoints"`
	Averagerank             interface{} `json:"averagerank"`
	Tournamentsparticipated int64       `json:"tournamentsparticipated"`
	Currentrank             int64       `json:"currentrank"`
	Totalschools            int64       `json:"totalschools"`
	Lasttournamentdate      interface{} `json:"lasttournamentdate"`
}

func (q *Queries) GetOverallSchoolRanking(ctx context.Context, schoolid int32) ([]GetOverallSchoolRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getOverallSchoolRanking, schoolid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverallSchoolRankingRow{}
	for rows.Next() {
		var i GetOverallSchoolRankingRow
		if err := rows.Scan(
			&i.Schoolid,
			&i.Schoolname,
			&i.Totalpoints,
			&i.Averagerank,
			&i.Tournamentsparticipated,
			&i.Currentrank,
			&i.Totalschools,
			&i.Lasttournamentdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverallStudentRanking = `-- name: GetOverallStudentRanking :many
WITH student_ranking AS (
    SELECT
        s.StudentID,
        s.FirstName || ' ' || s.LastName AS StudentName,
        CAST(SUM(ss.SpeakerPoints) AS DECIMAL(10,2)) AS TotalPoints,
        AVG(ss.SpeakerRank) AS AverageRank,
        COUNT(DISTINCT d.TournamentID) AS TournamentsParticipated,
        RANK() OVER (ORDER BY SUM(ss.SpeakerPoints) DESC, AVG(ss.SpeakerRank) ASC) AS CurrentRank,
        COUNT(*) OVER () AS TotalStudents,
        MAX(t.StartDate) AS LastTournamentDate
    FROM
        Students s
    JOIN TeamMembers tm ON s.StudentID = tm.StudentID
    JOIN Teams te ON tm.TeamID = te.TeamID
    JOIN Debates d ON (te.TeamID = d.Team1ID OR te.TeamID = d.Team2ID)
    JOIN Ballots b ON d.DebateID = b.DebateID
    JOIN SpeakerScores ss ON s.StudentID = ss.SpeakerID AND b.BallotID = ss.BallotID
    JOIN Tournaments t ON d.TournamentID = t.TournamentID
    GROUP BY
        s.StudentID, s.FirstName, s.LastName
)
SELECT studentid, studentname, totalpoints, averagerank, tournamentsparticipated, currentrank, totalstudents, lasttournamentdate
FROM student_ranking
ORDER BY CurrentRank
`

type GetOverallStudentRankingRow struct {
	Studentid               int32       `json:"studentid"`
	Studentname             interface{} `json:"studentname"`
	Totalpoints             string      `json:"totalpoints"`
	Averagerank             float64     `json:"averagerank"`
	Tournamentsparticipated int64       `json:"tournamentsparticipated"`
	Currentrank             int64       `json:"currentrank"`
	Totalstudents           int64       `json:"totalstudents"`
	Lasttournamentdate      interface{} `json:"lasttournamentdate"`
}

func (q *Queries) GetOverallStudentRanking(ctx context.Context) ([]GetOverallStudentRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getOverallStudentRanking)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverallStudentRankingRow{}
	for rows.Next() {
		var i GetOverallStudentRankingRow
		if err := rows.Scan(
			&i.Studentid,
			&i.Studentname,
			&i.Totalpoints,
			&i.Averagerank,
			&i.Tournamentsparticipated,
			&i.Currentrank,
			&i.Totalstudents,
			&i.Lasttournamentdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOverallVolunteerRanking = `-- name: GetOverallVolunteerRanking :many
WITH volunteer_ranking AS (
    SELECT
        v.VolunteerID,
        v.FirstName || ' ' || v.LastName AS VolunteerName,
        AVG(jf.AverageRating) as AverageRating,
        COUNT(DISTINCT d.TournamentID) as TournamentsJudged,
        RANK() OVER (ORDER BY AVG(jf.AverageRating) DESC) as CurrentRank,
        COUNT(*) OVER () as TotalVolunteers,
        MAX(t.StartDate) as LastTournamentDate
    FROM
        Volunteers v
        LEFT JOIN JudgeAssignments ja ON v.UserID = ja.JudgeID
        LEFT JOIN Debates d ON ja.DebateID = d.DebateID
        LEFT JOIN JudgeFeedback jf ON v.UserID = jf.JudgeID
        LEFT JOIN Tournaments t ON d.TournamentID = t.TournamentID
    GROUP BY
        v.VolunteerID, v.FirstName, v.LastName
)
SELECT volunteerid, volunteername, averagerating, tournamentsjudged, currentrank, totalvolunteers, lasttournamentdate
FROM volunteer_ranking
ORDER BY CurrentRank
`

type GetOverallVolunteerRankingRow struct {
	Volunteerid        int32       `json:"volunteerid"`
	Volunteername      interface{} `json:"volunteername"`
	Averagerating      float64     `json:"averagerating"`
	Tournamentsjudged  int64       `json:"tournamentsjudged"`
	Currentrank        int64       `json:"currentrank"`
	Totalvolunteers    int64       `json:"totalvolunteers"`
	Lasttournamentdate interface{} `json:"lasttournamentdate"`
}

func (q *Queries) GetOverallVolunteerRanking(ctx context.Context) ([]GetOverallVolunteerRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getOverallVolunteerRanking)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOverallVolunteerRankingRow{}
	for rows.Next() {
		var i GetOverallVolunteerRankingRow
		if err := rows.Scan(
			&i.Volunteerid,
			&i.Volunteername,
			&i.Averagerating,
			&i.Tournamentsjudged,
			&i.Currentrank,
			&i.Totalvolunteers,
			&i.Lasttournamentdate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPairingByID = `-- name: GetPairingByID :one
SELECT d.DebateID, d.RoundNumber, d.IsEliminationRound,
       d.Team1ID, t1.Name AS Team1Name, d.Team2ID, t2.Name AS Team2Name,
       d.RoomID, r.roomname AS RoomName,
       array_agg(DISTINCT s1.FirstName || ' ' || s1.LastName) AS Team1SpeakerNames,
       array_agg(DISTINCT s2.FirstName || ' ' || s2.LastName) AS Team2SpeakerNames,
       l1.Name AS Team1LeagueName, l2.Name AS Team2LeagueName,
       COALESCE(t1_points.TotalPoints, 0) AS Team1TotalPoints,
       COALESCE(t2_points.TotalPoints, 0) AS Team2TotalPoints,
       (SELECT u.Name FROM JudgeAssignments ja
        JOIN Users u ON ja.JudgeID = u.UserID
        WHERE ja.DebateID = d.DebateID AND ja.IsHeadJudge = true
        LIMIT 1) AS HeadJudgeName
FROM Debates d
JOIN Teams t1 ON d.Team1ID = t1.TeamID
JOIN Teams t2 ON d.Team2ID = t2.TeamID
LEFT JOIN Rooms r ON d.RoomID = r.RoomID
LEFT JOIN TeamMembers tm1 ON t1.TeamID = tm1.TeamID
LEFT JOIN TeamMembers tm2 ON t2.TeamID = tm2.TeamID
LEFT JOIN Students s1 ON tm1.StudentID = s1.StudentID
LEFT JOIN Students s2 ON tm2.StudentID = s2.StudentID
LEFT JOIN Tournaments tour ON d.TournamentID = tour.TournamentID
LEFT JOIN Leagues l1 ON tour.LeagueID = l1.LeagueID
LEFT JOIN Leagues l2 ON tour.LeagueID = l2.LeagueID
LEFT JOIN (
    SELECT Team1ID AS TeamID, SUM(Team1TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = (SELECT TournamentID FROM Debates WHERE d.DebateID = $1)
    GROUP BY Team1ID
    UNION ALL
    SELECT Team2ID AS TeamID, SUM(Team2TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = (SELECT TournamentID FROM Debates WHERE d.DebateID = $1)
    GROUP BY Team2ID
) t1_points ON t1.TeamID = t1_points.TeamID
LEFT JOIN (
    SELECT Team1ID AS TeamID, SUM(Team1TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = (SELECT TournamentID FROM Debates WHERE d.DebateID = $1)
    GROUP BY Team1ID
    UNION ALL
    SELECT Team2ID AS TeamID, SUM(Team2TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = (SELECT TournamentID FROM Debates WHERE d.DebateID = $1)
    GROUP BY Team2ID
) t2_points ON t2.TeamID = t2_points.TeamID
WHERE d.DebateID = $1
GROUP BY d.DebateID, d.RoundNumber, d.IsEliminationRound, d.Team1ID, t1.Name, d.Team2ID, t2.Name, d.RoomID, r.RoomName,
         l1.Name, l2.Name, t1_points.TotalPoints, t2_points.TotalPoints
`

type GetPairingByIDRow struct {
	Debateid           int32          `json:"debateid"`
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Team1id            int32          `json:"team1id"`
	Team1name          string         `json:"team1name"`
	Team2id            int32          `json:"team2id"`
	Team2name          string         `json:"team2name"`
	Roomid             int32          `json:"roomid"`
	Roomname           sql.NullString `json:"roomname"`
	Team1speakernames  interface{}    `json:"team1speakernames"`
	Team2speakernames  interface{}    `json:"team2speakernames"`
	Team1leaguename    sql.NullString `json:"team1leaguename"`
	Team2leaguename    sql.NullString `json:"team2leaguename"`
	Team1totalpoints   int64          `json:"team1totalpoints"`
	Team2totalpoints   int64          `json:"team2totalpoints"`
	Headjudgename      string         `json:"headjudgename"`
}

func (q *Queries) GetPairingByID(ctx context.Context, debateid int32) (GetPairingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPairingByID, debateid)
	var i GetPairingByIDRow
	err := row.Scan(
		&i.Debateid,
		&i.Roundnumber,
		&i.Iseliminationround,
		&i.Team1id,
		&i.Team1name,
		&i.Team2id,
		&i.Team2name,
		&i.Roomid,
		&i.Roomname,
		&i.Team1speakernames,
		&i.Team2speakernames,
		&i.Team1leaguename,
		&i.Team2leaguename,
		&i.Team1totalpoints,
		&i.Team2totalpoints,
		&i.Headjudgename,
	)
	return i, err
}

const getPairings = `-- name: GetPairings :many
SELECT
    d.debateid,
    d.roundnumber,
    d.iseliminationround,
    d.roomid,
    r.roomname,
    t1.teamid AS team1id,
    t1.name AS team1name,
    t2.teamid AS team2id,
    t2.name AS team2name,
    j.name AS headjudgename
FROM
    Debates d
    JOIN Rooms r ON d.roomid = r.roomid
    JOIN Teams t1 ON d.team1id = t1.teamid
    JOIN Teams t2 ON d.team2id = t2.teamid
    LEFT JOIN JudgeAssignments ja ON d.debateid = ja.debateid AND ja.isheadjudge = true
    LEFT JOIN Users j ON ja.judgeid = j.userid
WHERE
    d.tournamentid = $1
    AND d.roundnumber = $2
    AND d.iseliminationround = $3
ORDER BY
    d.debateid
`

type GetPairingsParams struct {
	Tournamentid       int32 `json:"tournamentid"`
	Roundnumber        int32 `json:"roundnumber"`
	Iseliminationround bool  `json:"iseliminationround"`
}

type GetPairingsRow struct {
	Debateid           int32          `json:"debateid"`
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Roomid             int32          `json:"roomid"`
	Roomname           string         `json:"roomname"`
	Team1id            int32          `json:"team1id"`
	Team1name          string         `json:"team1name"`
	Team2id            int32          `json:"team2id"`
	Team2name          string         `json:"team2name"`
	Headjudgename      sql.NullString `json:"headjudgename"`
}

func (q *Queries) GetPairings(ctx context.Context, arg GetPairingsParams) ([]GetPairingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPairings, arg.Tournamentid, arg.Roundnumber, arg.Iseliminationround)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPairingsRow{}
	for rows.Next() {
		var i GetPairingsRow
		if err := rows.Scan(
			&i.Debateid,
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Roomid,
			&i.Roomname,
			&i.Team1id,
			&i.Team1name,
			&i.Team2id,
			&i.Team2name,
			&i.Headjudgename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPairingsByTournamentAndRound = `-- name: GetPairingsByTournamentAndRound :many
SELECT d.DebateID, d.RoundNumber, d.IsEliminationRound,
       d.Team1ID, t1.Name AS Team1Name, d.Team2ID, t2.Name AS Team2Name,
       d.RoomID, r.roomname AS RoomName,
       array_agg(DISTINCT s1.FirstName || ' ' || s1.LastName) AS Team1SpeakerNames,
       array_agg(DISTINCT s2.FirstName || ' ' || s2.LastName) AS Team2SpeakerNames,
       l1.Name AS Team1LeagueName, l2.Name AS Team2LeagueName,
       COALESCE(t1_points.TotalPoints, 0) AS Team1TotalPoints,
       COALESCE(t2_points.TotalPoints, 0) AS Team2TotalPoints,
       (SELECT u.Name FROM JudgeAssignments ja
        JOIN Users u ON ja.JudgeID = u.UserID
        WHERE ja.DebateID = d.DebateID AND ja.IsHeadJudge = true
        LIMIT 1) AS HeadJudgeName
FROM Debates d
JOIN Teams t1 ON d.Team1ID = t1.TeamID
JOIN Teams t2 ON d.Team2ID = t2.TeamID
LEFT JOIN Rooms r ON d.RoomID = r.RoomID
LEFT JOIN TeamMembers tm1 ON t1.TeamID = tm1.TeamID
LEFT JOIN TeamMembers tm2 ON t2.TeamID = tm2.TeamID
LEFT JOIN Students s1 ON tm1.StudentID = s1.StudentID
LEFT JOIN Students s2 ON tm2.StudentID = s2.StudentID
LEFT JOIN Tournaments tour ON d.TournamentID = tour.TournamentID
LEFT JOIN Leagues l1 ON tour.LeagueID = l1.LeagueID
LEFT JOIN Leagues l2 ON tour.LeagueID = l2.LeagueID
LEFT JOIN (
    SELECT Team1ID AS TeamID, SUM(Team1TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = $1
    GROUP BY Team1ID
    UNION ALL
    SELECT Team2ID AS TeamID, SUM(Team2TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = $1
    GROUP BY Team2ID
) t1_points ON t1.TeamID = t1_points.TeamID
LEFT JOIN (
    SELECT Team1ID AS TeamID, SUM(Team1TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = $1
    GROUP BY Team1ID
    UNION ALL
    SELECT Team2ID AS TeamID, SUM(Team2TotalScore) AS TotalPoints
    FROM Ballots b
    JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = $1
    GROUP BY Team2ID
) t2_points ON t2.TeamID = t2_points.TeamID
WHERE d.TournamentID = $1 AND d.RoundNumber = $2 AND d.IsEliminationRound = $3
GROUP BY d.DebateID, d.RoundNumber, d.IsEliminationRound, d.Team1ID, t1.Name, d.Team2ID, t2.Name, d.RoomID, r.RoomName,
         l1.Name, l2.Name, t1_points.TotalPoints, t2_points.TotalPoints
`

type GetPairingsByTournamentAndRoundParams struct {
	Tournamentid       int32 `json:"tournamentid"`
	Roundnumber        int32 `json:"roundnumber"`
	Iseliminationround bool  `json:"iseliminationround"`
}

type GetPairingsByTournamentAndRoundRow struct {
	Debateid           int32          `json:"debateid"`
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Team1id            int32          `json:"team1id"`
	Team1name          string         `json:"team1name"`
	Team2id            int32          `json:"team2id"`
	Team2name          string         `json:"team2name"`
	Roomid             int32          `json:"roomid"`
	Roomname           sql.NullString `json:"roomname"`
	Team1speakernames  interface{}    `json:"team1speakernames"`
	Team2speakernames  interface{}    `json:"team2speakernames"`
	Team1leaguename    sql.NullString `json:"team1leaguename"`
	Team2leaguename    sql.NullString `json:"team2leaguename"`
	Team1totalpoints   int64          `json:"team1totalpoints"`
	Team2totalpoints   int64          `json:"team2totalpoints"`
	Headjudgename      string         `json:"headjudgename"`
}

func (q *Queries) GetPairingsByTournamentAndRound(ctx context.Context, arg GetPairingsByTournamentAndRoundParams) ([]GetPairingsByTournamentAndRoundRow, error) {
	rows, err := q.db.QueryContext(ctx, getPairingsByTournamentAndRound, arg.Tournamentid, arg.Roundnumber, arg.Iseliminationround)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPairingsByTournamentAndRoundRow{}
	for rows.Next() {
		var i GetPairingsByTournamentAndRoundRow
		if err := rows.Scan(
			&i.Debateid,
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Team1id,
			&i.Team1name,
			&i.Team2id,
			&i.Team2name,
			&i.Roomid,
			&i.Roomname,
			&i.Team1speakernames,
			&i.Team2speakernames,
			&i.Team1leaguename,
			&i.Team2leaguename,
			&i.Team1totalpoints,
			&i.Team2totalpoints,
			&i.Headjudgename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPreviousPairings = `-- name: GetPreviousPairings :many
SELECT Team1ID, Team2ID
FROM Debates
WHERE TournamentID = $1 AND RoundNumber < $2
`

type GetPreviousPairingsParams struct {
	Tournamentid int32 `json:"tournamentid"`
	Roundnumber  int32 `json:"roundnumber"`
}

type GetPreviousPairingsRow struct {
	Team1id int32 `json:"team1id"`
	Team2id int32 `json:"team2id"`
}

func (q *Queries) GetPreviousPairings(ctx context.Context, arg GetPreviousPairingsParams) ([]GetPreviousPairingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPreviousPairings, arg.Tournamentid, arg.Roundnumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPreviousPairingsRow{}
	for rows.Next() {
		var i GetPreviousPairingsRow
		if err := rows.Scan(&i.Team1id, &i.Team2id); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRankingVisibility = `-- name: GetRankingVisibility :one
SELECT IsVisible
FROM RankingVisibility
WHERE TournamentID = $1 AND RankingType = $2 AND VisibleTo = $3
`

type GetRankingVisibilityParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Rankingtype  string `json:"rankingtype"`
	Visibleto    string `json:"visibleto"`
}

func (q *Queries) GetRankingVisibility(ctx context.Context, arg GetRankingVisibilityParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getRankingVisibility, arg.Tournamentid, arg.Rankingtype, arg.Visibleto)
	var isvisible bool
	err := row.Scan(&isvisible)
	return isvisible, err
}

const getRoomByID = `-- name: GetRoomByID :one
SELECT RoomID, RoomName, TournamentID, Location, Capacity
FROM Rooms
WHERE RoomID = $1
`

type GetRoomByIDRow struct {
	Roomid       int32         `json:"roomid"`
	Roomname     string        `json:"roomname"`
	Tournamentid sql.NullInt32 `json:"tournamentid"`
	Location     string        `json:"location"`
	Capacity     int32         `json:"capacity"`
}

func (q *Queries) GetRoomByID(ctx context.Context, roomid int32) (GetRoomByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRoomByID, roomid)
	var i GetRoomByIDRow
	err := row.Scan(
		&i.Roomid,
		&i.Roomname,
		&i.Tournamentid,
		&i.Location,
		&i.Capacity,
	)
	return i, err
}

const getRoomsByTournament = `-- name: GetRoomsByTournament :many
SELECT roomid, roomname, location, capacity, tournamentid FROM Rooms
WHERE TournamentID = $1
`

func (q *Queries) GetRoomsByTournament(ctx context.Context, tournamentid sql.NullInt32) ([]Room, error) {
	rows, err := q.db.QueryContext(ctx, getRoomsByTournament, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Room{}
	for rows.Next() {
		var i Room
		if err := rows.Scan(
			&i.Roomid,
			&i.Roomname,
			&i.Location,
			&i.Capacity,
			&i.Tournamentid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoundByTournamentAndNumber = `-- name: GetRoundByTournamentAndNumber :one
SELECT roundid, tournamentid, roundnumber, iseliminationround FROM Rounds
WHERE TournamentID = $1 AND RoundNumber = $2 AND IsEliminationRound = $3
LIMIT 1
`

type GetRoundByTournamentAndNumberParams struct {
	Tournamentid       int32 `json:"tournamentid"`
	Roundnumber        int32 `json:"roundnumber"`
	Iseliminationround bool  `json:"iseliminationround"`
}

func (q *Queries) GetRoundByTournamentAndNumber(ctx context.Context, arg GetRoundByTournamentAndNumberParams) (Round, error) {
	row := q.db.QueryRowContext(ctx, getRoundByTournamentAndNumber, arg.Tournamentid, arg.Roundnumber, arg.Iseliminationround)
	var i Round
	err := row.Scan(
		&i.Roundid,
		&i.Tournamentid,
		&i.Roundnumber,
		&i.Iseliminationround,
	)
	return i, err
}

const getSchoolOverallPerformance = `-- name: GetSchoolOverallPerformance :many
WITH tournament_performance AS (
  SELECT
    d.TournamentID,
    t.StartDate,
    s.SchoolID,
    CAST(SUM(ts.TotalScore) AS DECIMAL(10,2)) AS SchoolTotalPoints,
    CAST(AVG(ts.TotalScore) AS DECIMAL(10,2)) AS SchoolAveragePoints,
    CAST(AVG(SUM(ts.TotalScore)) OVER (PARTITION BY d.TournamentID) AS DECIMAL(10,2)) AS OverallAverageTotalPoints,
    CAST(AVG(AVG(ts.TotalScore)) OVER (PARTITION BY d.TournamentID) AS DECIMAL(10,2)) AS OverallAveragePoints,
    RANK() OVER (PARTITION BY d.TournamentID ORDER BY SUM(ts.TotalScore) DESC) AS TournamentRank
  FROM
    Schools s
    JOIN Students stu ON s.SchoolID = stu.SchoolID
    JOIN TeamMembers tm ON stu.StudentID = tm.StudentID
    JOIN Teams te ON tm.TeamID = te.TeamID
    JOIN Debates d ON (te.TeamID = d.Team1ID OR te.TeamID = d.Team2ID)
    JOIN TeamScores ts ON te.TeamID = ts.TeamID AND d.DebateID = ts.DebateID
    JOIN Tournaments t ON d.TournamentID = t.TournamentID
    LEFT JOIN Leagues l ON t.LeagueID = l.LeagueID
  WHERE
    s.SchoolID = $1 AND t.StartDate BETWEEN $2 AND $3 AND l.Name != 'DAC'
  GROUP BY
    d.TournamentID, t.StartDate, s.SchoolID
)
SELECT
  StartDate,
  SchoolTotalPoints,
  SchoolAveragePoints,
  OverallAverageTotalPoints,
  OverallAveragePoints,
  TournamentRank
FROM
  tournament_performance
ORDER BY
  StartDate
`

type GetSchoolOverallPerformanceParams struct {
	Schoolid    int32     `json:"schoolid"`
	Startdate   time.Time `json:"startdate"`
	Startdate_2 time.Time `json:"startdate_2"`
}

type GetSchoolOverallPerformanceRow struct {
	Startdate                 time.Time `json:"startdate"`
	Schooltotalpoints         string    `json:"schooltotalpoints"`
	Schoolaveragepoints       string    `json:"schoolaveragepoints"`
	Overallaveragetotalpoints string    `json:"overallaveragetotalpoints"`
	Overallaveragepoints      string    `json:"overallaveragepoints"`
	Tournamentrank            int64     `json:"tournamentrank"`
}

func (q *Queries) GetSchoolOverallPerformance(ctx context.Context, arg GetSchoolOverallPerformanceParams) ([]GetSchoolOverallPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getSchoolOverallPerformance, arg.Schoolid, arg.Startdate, arg.Startdate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSchoolOverallPerformanceRow{}
	for rows.Next() {
		var i GetSchoolOverallPerformanceRow
		if err := rows.Scan(
			&i.Startdate,
			&i.Schooltotalpoints,
			&i.Schoolaveragepoints,
			&i.Overallaveragetotalpoints,
			&i.Overallaveragepoints,
			&i.Tournamentrank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSinglePairing = `-- name: GetSinglePairing :one
SELECT
    d.debateid,
    d.roundnumber,
    d.iseliminationround,
    d.roomid,
    r.roomname,
    t1.teamid AS team1id,
    t1.name AS team1name,
    t2.teamid AS team2id,
    t2.name AS team2name,
    j.name AS headjudgename
FROM
    Debates d
    JOIN Rooms r ON d.roomid = r.roomid
    JOIN Teams t1 ON d.team1id = t1.teamid
    JOIN Teams t2 ON d.team2id = t2.teamid
    LEFT JOIN JudgeAssignments ja ON d.debateid = ja.debateid AND ja.isheadjudge = true
    LEFT JOIN Users j ON ja.judgeid = j.userid
WHERE
    d.debateid = $1
`

type GetSinglePairingRow struct {
	Debateid           int32          `json:"debateid"`
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Roomid             int32          `json:"roomid"`
	Roomname           string         `json:"roomname"`
	Team1id            int32          `json:"team1id"`
	Team1name          string         `json:"team1name"`
	Team2id            int32          `json:"team2id"`
	Team2name          string         `json:"team2name"`
	Headjudgename      sql.NullString `json:"headjudgename"`
}

func (q *Queries) GetSinglePairing(ctx context.Context, debateid int32) (GetSinglePairingRow, error) {
	row := q.db.QueryRowContext(ctx, getSinglePairing, debateid)
	var i GetSinglePairingRow
	err := row.Scan(
		&i.Debateid,
		&i.Roundnumber,
		&i.Iseliminationround,
		&i.Roomid,
		&i.Roomname,
		&i.Team1id,
		&i.Team1name,
		&i.Team2id,
		&i.Team2name,
		&i.Headjudgename,
	)
	return i, err
}

const getSpeakerScoresByBallot = `-- name: GetSpeakerScoresByBallot :many
SELECT ss.ScoreID, ss.SpeakerID, s.FirstName, s.LastName,
       ss.SpeakerRank, ss.SpeakerPoints, ss.Feedback,
       t.TeamID, t.Name AS TeamName
FROM SpeakerScores ss
         JOIN Students s ON ss.SpeakerID = s.StudentID
         JOIN Ballots b ON ss.BallotID = b.BallotID
         JOIN Debates d ON b.DebateID = d.DebateID
         JOIN TeamMembers tm ON s.StudentID = tm.StudentID
         JOIN Teams t ON tm.TeamID = t.TeamID
WHERE ss.BallotID = $1
  AND (t.TeamID = d.Team1ID OR t.TeamID = d.Team2ID)
ORDER BY t.TeamID, ss.SpeakerRank
`

type GetSpeakerScoresByBallotRow struct {
	Scoreid       int32          `json:"scoreid"`
	Speakerid     int32          `json:"speakerid"`
	Firstname     string         `json:"firstname"`
	Lastname      string         `json:"lastname"`
	Speakerrank   int32          `json:"speakerrank"`
	Speakerpoints string         `json:"speakerpoints"`
	Feedback      sql.NullString `json:"feedback"`
	Teamid        int32          `json:"teamid"`
	Teamname      string         `json:"teamname"`
}

func (q *Queries) GetSpeakerScoresByBallot(ctx context.Context, ballotid int32) ([]GetSpeakerScoresByBallotRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpeakerScoresByBallot, ballotid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpeakerScoresByBallotRow{}
	for rows.Next() {
		var i GetSpeakerScoresByBallotRow
		if err := rows.Scan(
			&i.Scoreid,
			&i.Speakerid,
			&i.Firstname,
			&i.Lastname,
			&i.Speakerrank,
			&i.Speakerpoints,
			&i.Feedback,
			&i.Teamid,
			&i.Teamname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpeakerScoresByBallotAndTeam = `-- name: GetSpeakerScoresByBallotAndTeam :many
SELECT ss.ScoreID, ss.SpeakerID, ss.BallotID, ss.SpeakerRank,
       ss.SpeakerPoints, ss.Feedback, tm.TeamID
FROM SpeakerScores ss
         JOIN TeamMembers tm ON ss.SpeakerID = tm.StudentID
WHERE ss.BallotID = $1 AND tm.TeamID = $2
ORDER BY ss.SpeakerRank
`

type GetSpeakerScoresByBallotAndTeamParams struct {
	Ballotid int32 `json:"ballotid"`
	Teamid   int32 `json:"teamid"`
}

type GetSpeakerScoresByBallotAndTeamRow struct {
	Scoreid       int32          `json:"scoreid"`
	Speakerid     int32          `json:"speakerid"`
	Ballotid      int32          `json:"ballotid"`
	Speakerrank   int32          `json:"speakerrank"`
	Speakerpoints string         `json:"speakerpoints"`
	Feedback      sql.NullString `json:"feedback"`
	Teamid        int32          `json:"teamid"`
}

func (q *Queries) GetSpeakerScoresByBallotAndTeam(ctx context.Context, arg GetSpeakerScoresByBallotAndTeamParams) ([]GetSpeakerScoresByBallotAndTeamRow, error) {
	rows, err := q.db.QueryContext(ctx, getSpeakerScoresByBallotAndTeam, arg.Ballotid, arg.Teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSpeakerScoresByBallotAndTeamRow{}
	for rows.Next() {
		var i GetSpeakerScoresByBallotAndTeamRow
		if err := rows.Scan(
			&i.Scoreid,
			&i.Speakerid,
			&i.Ballotid,
			&i.Speakerrank,
			&i.Speakerpoints,
			&i.Feedback,
			&i.Teamid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentFeedback = `-- name: GetStudentFeedback :many
WITH debate_judges AS (
    SELECT
        ja.DebateID,
        json_agg(
            json_build_object(
                'judge_id', ja.JudgeID,
                'judge_name', u.Name,
                'is_head_judge', ja.IsHeadJudge
            )
        ) as judges
    FROM JudgeAssignments ja
    JOIN Users u ON ja.JudgeID = u.UserID
    GROUP BY ja.DebateID
)
SELECT
    d.RoundNumber,
    d.IsEliminationRound,
    d.DebateID,
    b.BallotID,
    ss.SpeakerPoints,
    ss.Feedback,
    ss.IsRead,
    u.Name as HeadJudgeName,
    r.RoomName,
    t1.Name as OpponentTeamName,
    t2.Name as StudentTeamName,
    dj.judges::text as JudgesInfo
FROM SpeakerScores ss
JOIN Ballots b ON ss.BallotID = b.BallotID
JOIN Debates d ON b.DebateID = d.DebateID
JOIN JudgeAssignments ja ON d.DebateID = ja.DebateID AND ja.IsHeadJudge = true
JOIN Users u ON ja.JudgeID = u.UserID
JOIN Rooms r ON d.RoomID = r.RoomID
JOIN Teams t1 ON (d.Team1ID = t1.TeamID)
JOIN Teams t2 ON (d.Team2ID = t2.TeamID AND t2.TeamID IN (
    SELECT TeamID FROM TeamMembers WHERE StudentID = $1
))
LEFT JOIN debate_judges dj ON d.DebateID = dj.DebateID
WHERE ss.SpeakerID = $1
  AND d.TournamentID = $2
ORDER BY d.RoundNumber
LIMIT $3 OFFSET $4
`

type GetStudentFeedbackParams struct {
	Studentid    int32 `json:"studentid"`
	Tournamentid int32 `json:"tournamentid"`
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
}

type GetStudentFeedbackRow struct {
	Roundnumber        int32          `json:"roundnumber"`
	Iseliminationround bool           `json:"iseliminationround"`
	Debateid           int32          `json:"debateid"`
	Ballotid           int32          `json:"ballotid"`
	Speakerpoints      string         `json:"speakerpoints"`
	Feedback           sql.NullString `json:"feedback"`
	Isread             sql.NullBool   `json:"isread"`
	Headjudgename      string         `json:"headjudgename"`
	Roomname           string         `json:"roomname"`
	Opponentteamname   string         `json:"opponentteamname"`
	Studentteamname    string         `json:"studentteamname"`
	Judgesinfo         string         `json:"judgesinfo"`
}

func (q *Queries) GetStudentFeedback(ctx context.Context, arg GetStudentFeedbackParams) ([]GetStudentFeedbackRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentFeedback,
		arg.Studentid,
		arg.Tournamentid,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentFeedbackRow{}
	for rows.Next() {
		var i GetStudentFeedbackRow
		if err := rows.Scan(
			&i.Roundnumber,
			&i.Iseliminationround,
			&i.Debateid,
			&i.Ballotid,
			&i.Speakerpoints,
			&i.Feedback,
			&i.Isread,
			&i.Headjudgename,
			&i.Roomname,
			&i.Opponentteamname,
			&i.Studentteamname,
			&i.Judgesinfo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentFeedbackCount = `-- name: GetStudentFeedbackCount :one
SELECT COUNT(*)
FROM SpeakerScores ss
JOIN Ballots b ON ss.BallotID = b.BallotID
JOIN Debates d ON b.DebateID = d.DebateID
WHERE ss.SpeakerID = $1 AND d.TournamentID = $2
`

type GetStudentFeedbackCountParams struct {
	Speakerid    int32 `json:"speakerid"`
	Tournamentid int32 `json:"tournamentid"`
}

func (q *Queries) GetStudentFeedbackCount(ctx context.Context, arg GetStudentFeedbackCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getStudentFeedbackCount, arg.Speakerid, arg.Tournamentid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStudentOverallPerformance = `-- name: GetStudentOverallPerformance :many
WITH tournament_performance AS (
    SELECT
        d.TournamentID,
        t.StartDate,
        s.StudentID,
        CAST(SUM(ss.SpeakerPoints) AS NUMERIC(10,2)) AS StudentTotalPoints,
        CAST(AVG(ss.SpeakerPoints) AS NUMERIC(10,2)) AS StudentAveragePoints,
        CAST(AVG(SUM(ss.SpeakerPoints)) OVER (PARTITION BY d.TournamentID) AS NUMERIC(10,2)) AS OverallAverageTotalPoints,
        CAST(AVG(AVG(ss.SpeakerPoints)) OVER (PARTITION BY d.TournamentID) AS NUMERIC(10,2)) AS OverallAveragePoints,
        RANK() OVER (PARTITION BY d.TournamentID ORDER BY SUM(ss.SpeakerPoints) DESC) AS TournamentRank
    FROM
        Students s
    JOIN TeamMembers tm ON s.StudentID = tm.StudentID
    JOIN Teams te ON tm.TeamID = te.TeamID
    JOIN Debates d ON (te.TeamID = d.Team1ID OR te.TeamID = d.Team2ID)
    JOIN Ballots b ON d.DebateID = b.DebateID
    JOIN SpeakerScores ss ON s.StudentID = ss.SpeakerID AND b.BallotID = ss.BallotID
    JOIN Tournaments t ON d.TournamentID = t.TournamentID
    WHERE
        s.StudentID = $1 AND t.StartDate BETWEEN $2 AND $3
    GROUP BY
        d.TournamentID, t.StartDate, s.StudentID
)
SELECT
    StartDate,
    StudentTotalPoints,
    StudentAveragePoints,
    OverallAverageTotalPoints,
    OverallAveragePoints,
    TournamentRank
FROM
    tournament_performance
ORDER BY
    StartDate
`

type GetStudentOverallPerformanceParams struct {
	Studentid   int32     `json:"studentid"`
	Startdate   time.Time `json:"startdate"`
	Startdate_2 time.Time `json:"startdate_2"`
}

type GetStudentOverallPerformanceRow struct {
	Startdate                 time.Time `json:"startdate"`
	Studenttotalpoints        string    `json:"studenttotalpoints"`
	Studentaveragepoints      string    `json:"studentaveragepoints"`
	Overallaveragetotalpoints string    `json:"overallaveragetotalpoints"`
	Overallaveragepoints      string    `json:"overallaveragepoints"`
	Tournamentrank            int64     `json:"tournamentrank"`
}

func (q *Queries) GetStudentOverallPerformance(ctx context.Context, arg GetStudentOverallPerformanceParams) ([]GetStudentOverallPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getStudentOverallPerformance, arg.Studentid, arg.Startdate, arg.Startdate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentOverallPerformanceRow{}
	for rows.Next() {
		var i GetStudentOverallPerformanceRow
		if err := rows.Scan(
			&i.Startdate,
			&i.Studenttotalpoints,
			&i.Studentaveragepoints,
			&i.Overallaveragetotalpoints,
			&i.Overallaveragepoints,
			&i.Tournamentrank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentTournamentStats = `-- name: GetStudentTournamentStats :one
WITH student_stats AS (
    SELECT
        COUNT(DISTINCT t.TournamentID) AS attended_tournaments,
        (SELECT COUNT(*) FROM Tournaments WHERE StartDate >= CURRENT_DATE - INTERVAL '365 days') AS total_tournaments_last_year
    FROM
        Students s
    JOIN TeamMembers tm ON s.StudentID = tm.StudentID
    JOIN Teams te ON tm.TeamID = te.TeamID
    JOIN Tournaments t ON te.TournamentID = t.TournamentID
    WHERE
        s.StudentID = $1 AND t.StartDate >= CURRENT_DATE - INTERVAL '365 days'
),
current_stats AS (
    SELECT
        (SELECT COUNT(*) FROM Tournaments WHERE deleted_at IS NULL) AS total_tournaments,
        (SELECT COUNT(*) FROM Tournaments WHERE StartDate BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' AND deleted_at IS NULL) AS upcoming_tournaments
),
yesterday_stats AS (
    SELECT yesterday_total_count, yesterday_upcoming_count
    FROM Tournaments
    WHERE TournamentID = (SELECT MIN(TournamentID) FROM Tournaments)
)
SELECT
    cs.total_tournaments,
    ys.yesterday_total_count,
    cs.upcoming_tournaments,
    ys.yesterday_upcoming_count,
    ss.attended_tournaments,
    ss.total_tournaments_last_year
FROM
    current_stats cs, yesterday_stats ys, student_stats ss
`

type GetStudentTournamentStatsRow struct {
	TotalTournaments         int64         `json:"total_tournaments"`
	YesterdayTotalCount      sql.NullInt32 `json:"yesterday_total_count"`
	UpcomingTournaments      int64         `json:"upcoming_tournaments"`
	YesterdayUpcomingCount   sql.NullInt32 `json:"yesterday_upcoming_count"`
	AttendedTournaments      int64         `json:"attended_tournaments"`
	TotalTournamentsLastYear int64         `json:"total_tournaments_last_year"`
}

func (q *Queries) GetStudentTournamentStats(ctx context.Context, studentid int32) (GetStudentTournamentStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getStudentTournamentStats, studentid)
	var i GetStudentTournamentStatsRow
	err := row.Scan(
		&i.TotalTournaments,
		&i.YesterdayTotalCount,
		&i.UpcomingTournaments,
		&i.YesterdayUpcomingCount,
		&i.AttendedTournaments,
		&i.TotalTournamentsLastYear,
	)
	return i, err
}

const getTeamAverageRank = `-- name: GetTeamAverageRank :one
WITH speaker_ranks AS (
    SELECT ss.SpeakerRank
    FROM SpeakerScores ss
    JOIN TeamMembers tm ON ss.SpeakerID = tm.StudentID
    WHERE tm.TeamID = $1 AND ss.BallotID = $2
)
SELECT
    AVG(SpeakerRank)::FLOAT as AvgRank,
    COUNT(*) as SpeakerCount,
    array_agg(SpeakerRank) as AllRanks
FROM speaker_ranks
`

type GetTeamAverageRankParams struct {
	Teamid   int32 `json:"teamid"`
	Ballotid int32 `json:"ballotid"`
}

type GetTeamAverageRankRow struct {
	Avgrank      float64     `json:"avgrank"`
	Speakercount int64       `json:"speakercount"`
	Allranks     interface{} `json:"allranks"`
}

func (q *Queries) GetTeamAverageRank(ctx context.Context, arg GetTeamAverageRankParams) (GetTeamAverageRankRow, error) {
	row := q.db.QueryRowContext(ctx, getTeamAverageRank, arg.Teamid, arg.Ballotid)
	var i GetTeamAverageRankRow
	err := row.Scan(&i.Avgrank, &i.Speakercount, &i.Allranks)
	return i, err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT t.TeamID, t.Name, t.TournamentID,
       array_agg(tm.StudentID) as SpeakerIDs
FROM Teams t
LEFT JOIN TeamMembers tm ON t.TeamID = tm.TeamID
WHERE t.TeamID = $1
GROUP BY t.TeamID, t.Name, t.TournamentID
`

type GetTeamByIDRow struct {
	Teamid       int32       `json:"teamid"`
	Name         string      `json:"name"`
	Tournamentid int32       `json:"tournamentid"`
	Speakerids   interface{} `json:"speakerids"`
}

func (q *Queries) GetTeamByID(ctx context.Context, teamid int32) (GetTeamByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTeamByID, teamid)
	var i GetTeamByIDRow
	err := row.Scan(
		&i.Teamid,
		&i.Name,
		&i.Tournamentid,
		&i.Speakerids,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT tm.TeamID, tm.StudentID, s.FirstName, s.LastName
FROM TeamMembers tm
JOIN Students s ON tm.StudentID = s.StudentID
WHERE tm.TeamID = $1
`

type GetTeamMembersRow struct {
	Teamid    int32  `json:"teamid"`
	Studentid int32  `json:"studentid"`
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
}

func (q *Queries) GetTeamMembers(ctx context.Context, teamid int32) ([]GetTeamMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamMembers, teamid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamMembersRow{}
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.Teamid,
			&i.Studentid,
			&i.Firstname,
			&i.Lastname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamWins = `-- name: GetTeamWins :one
SELECT COUNT(*) as wins
FROM Debates d
JOIN Ballots b ON d.DebateID = b.DebateID
WHERE (d.Team1ID = $1 AND b.Team1TotalScore > b.Team2TotalScore)
   OR (d.Team2ID = $1 AND b.Team2TotalScore > b.Team1TotalScore)
   AND d.TournamentID = $2
`

type GetTeamWinsParams struct {
	Team1id      int32 `json:"team1id"`
	Tournamentid int32 `json:"tournamentid"`
}

func (q *Queries) GetTeamWins(ctx context.Context, arg GetTeamWinsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTeamWins, arg.Team1id, arg.Tournamentid)
	var wins int64
	err := row.Scan(&wins)
	return wins, err
}

const getTeamsByTournament = `-- name: GetTeamsByTournament :many
SELECT t.TeamID, t.Name, t.TournamentID,
       array_agg(tm.StudentID) as SpeakerIDs,
       (SELECT COUNT(*)
        FROM Debates d
        JOIN Ballots b ON d.DebateID = b.DebateID
        WHERE ((d.Team1ID = t.TeamID AND b.Team1TotalScore > b.Team2TotalScore)
           OR (d.Team2ID = t.TeamID AND b.Team2TotalScore > b.Team1TotalScore))
           AND d.TournamentID = $1) as Wins,
       l.Name as LeagueName
FROM Teams t
LEFT JOIN TeamMembers tm ON t.TeamID = tm.TeamID
JOIN Tournaments tour ON t.TournamentID = tour.TournamentID
JOIN Leagues l ON tour.LeagueID = l.LeagueID
WHERE t.TournamentID = $1
GROUP BY t.TeamID, t.Name, t.TournamentID, l.Name
`

type GetTeamsByTournamentRow struct {
	Teamid       int32       `json:"teamid"`
	Name         string      `json:"name"`
	Tournamentid int32       `json:"tournamentid"`
	Speakerids   interface{} `json:"speakerids"`
	Wins         int64       `json:"wins"`
	Leaguename   string      `json:"leaguename"`
}

func (q *Queries) GetTeamsByTournament(ctx context.Context, tournamentid int32) ([]GetTeamsByTournamentRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamsByTournament, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamsByTournamentRow{}
	for rows.Next() {
		var i GetTeamsByTournamentRow
		if err := rows.Scan(
			&i.Teamid,
			&i.Name,
			&i.Tournamentid,
			&i.Speakerids,
			&i.Wins,
			&i.Leaguename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPerformingTeams = `-- name: GetTopPerformingTeams :many
WITH ballot_check AS (
    SELECT COUNT(*) = 0 AS all_recorded
    FROM Ballots b
             JOIN Debates d ON b.DebateID = d.DebateID
    WHERE d.TournamentID = $1 AND d.IsEliminationRound = false AND b.RecordingStatus != 'Recorded'
),
     team_performance AS (
         SELECT
             t.TeamID,
             t.Name,
             t.TournamentID,
             COALESCE(t.TotalWins, 0) as Wins,
             COALESCE(t.TotalSpeakerPoints, 0) as TotalSpeakerPoints,
             COALESCE(t.AverageRank, 99) as AverageRank  -- Use 99 as default for ranking purposes
         FROM
             Teams t
         WHERE
             t.TournamentID = $1
           AND EXISTS (
             -- Only include teams that have participated in debates
             SELECT 1 FROM Debates d
             WHERE (d.Team1ID = t.TeamID OR d.Team2ID = t.TeamID)
               AND d.IsEliminationRound = false
         )
     )
SELECT
    tp.TeamID, tp.Name, tp.TournamentID, tp.Wins, tp.TotalSpeakerPoints, tp.AverageRank
FROM
    team_performance tp, ballot_check
WHERE
    ballot_check.all_recorded = true
ORDER BY
    tp.Wins DESC, tp.TotalSpeakerPoints DESC, tp.AverageRank ASC
LIMIT $2
`

type GetTopPerformingTeamsParams struct {
	Tournamentid int32 `json:"tournamentid"`
	Limit        int32 `json:"limit"`
}

type GetTopPerformingTeamsRow struct {
	Teamid             int32  `json:"teamid"`
	Name               string `json:"name"`
	Tournamentid       int32  `json:"tournamentid"`
	Wins               int32  `json:"wins"`
	Totalspeakerpoints string `json:"totalspeakerpoints"`
	Averagerank        string `json:"averagerank"`
}

func (q *Queries) GetTopPerformingTeams(ctx context.Context, arg GetTopPerformingTeamsParams) ([]GetTopPerformingTeamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopPerformingTeams, arg.Tournamentid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTopPerformingTeamsRow{}
	for rows.Next() {
		var i GetTopPerformingTeamsRow
		if err := rows.Scan(
			&i.Teamid,
			&i.Name,
			&i.Tournamentid,
			&i.Wins,
			&i.Totalspeakerpoints,
			&i.Averagerank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentSchoolRanking = `-- name: GetTournamentSchoolRanking :many
WITH SchoolData AS (
    SELECT
        s.SchoolID,
        s.SchoolName,
        COUNT(DISTINCT te.TeamID) AS TeamCount,
        COUNT(CASE WHEN b.Verdict = te.Name THEN 1 END) AS TotalWins,
        CAST(COALESCE(AVG(ts.Rank), 0) AS text) AS AverageRank,
        CAST(COALESCE(SUM(ts.TotalScore), 0) AS text) AS TotalPoints
    FROM Schools s
             JOIN Students stu ON s.SchoolID = stu.SchoolID
             JOIN TeamMembers tm ON stu.StudentID = tm.StudentID
             JOIN Teams te ON tm.TeamID = te.TeamID
             JOIN Tournaments tour ON te.TournamentID = tour.TournamentID
             LEFT JOIN Debates d ON (te.TeamID = d.Team1ID OR te.TeamID = d.Team2ID)
             LEFT JOIN Ballots b ON d.DebateID = b.DebateID
             LEFT JOIN TeamScores ts ON te.TeamID = ts.TeamID AND d.DebateID = ts.DebateID
             LEFT JOIN Leagues l ON tour.LeagueID = l.LeagueID
    WHERE te.TournamentID = $1
      AND l.Name != 'DAC'
      AND d.IsEliminationRound = false
    GROUP BY s.SchoolID, s.SchoolName
    HAVING COUNT(DISTINCT te.TeamID) > 0
),
     RankedSchools AS (
         SELECT
             SchoolName,
             TeamCount,
             TotalWins,
             AverageRank,
             TotalPoints,
             RANK() OVER (
                 ORDER BY TotalWins DESC,
                     CAST(TotalPoints AS numeric) DESC,
                     CAST(AverageRank AS numeric) ASC
                 ) as place
         FROM SchoolData
     ),
     TopThree AS (
         SELECT schoolname, teamcount, totalwins, averagerank, totalpoints, place
         FROM RankedSchools
         WHERE place <= 3
     ),
     SearchResults AS (
         SELECT schoolname, teamcount, totalwins, averagerank, totalpoints, place
         FROM RankedSchools
         WHERE $4::text IS NULL
            OR SchoolName ILIKE '%' || $4 || '%'
     )
SELECT DISTINCT ON (place) schoolname, teamcount, totalwins, averagerank, totalpoints, place
FROM (
         SELECT schoolname, teamcount, totalwins, averagerank, totalpoints, place FROM TopThree
         UNION
         SELECT schoolname, teamcount, totalwins, averagerank, totalpoints, place FROM SearchResults WHERE place > 3
     ) combined
ORDER BY place
LIMIT $2 OFFSET $3
`

type GetTournamentSchoolRankingParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Column4      string `json:"column_4"`
}

type GetTournamentSchoolRankingRow struct {
	Schoolname  string `json:"schoolname"`
	Teamcount   int64  `json:"teamcount"`
	Totalwins   int64  `json:"totalwins"`
	Averagerank string `json:"averagerank"`
	Totalpoints string `json:"totalpoints"`
	Place       int64  `json:"place"`
}

func (q *Queries) GetTournamentSchoolRanking(ctx context.Context, arg GetTournamentSchoolRankingParams) ([]GetTournamentSchoolRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentSchoolRanking,
		arg.Tournamentid,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentSchoolRankingRow{}
	for rows.Next() {
		var i GetTournamentSchoolRankingRow
		if err := rows.Scan(
			&i.Schoolname,
			&i.Teamcount,
			&i.Totalwins,
			&i.Averagerank,
			&i.Totalpoints,
			&i.Place,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentSchoolRankingCount = `-- name: GetTournamentSchoolRankingCount :one
SELECT COUNT(DISTINCT s.SchoolID)
FROM Schools s
JOIN Students stu ON s.SchoolID = stu.SchoolID
JOIN TeamMembers tm ON stu.StudentID = tm.StudentID
JOIN Teams t ON tm.TeamID = t.TeamID
JOIN Tournaments tour ON t.TournamentID = tour.TournamentID
LEFT JOIN Leagues l ON tour.LeagueID = l.LeagueID
WHERE t.TournamentID = $1 AND l.Name != 'DAC'
`

func (q *Queries) GetTournamentSchoolRankingCount(ctx context.Context, tournamentid int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTournamentSchoolRankingCount, tournamentid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTournamentStudentRanking = `-- name: GetTournamentStudentRanking :many
WITH RankedStudents AS (
    SELECT
        s.StudentID,
        s.FirstName || ' ' || s.LastName AS StudentName,
        sch.SchoolName,
        t.TotalWins AS TotalWins,
        CAST(SUM(ss.SpeakerPoints) AS DECIMAL(10,2)) AS TotalPoints,
        AVG(ss.SpeakerRank) AS AverageRank,
        RANK() OVER (ORDER BY SUM(ss.SpeakerPoints) DESC,
            t.TotalWins DESC,
            AVG(ss.SpeakerRank) ASC) as place
    FROM Students s
             JOIN TeamMembers tm ON s.StudentID = tm.StudentID
             JOIN Teams t ON tm.TeamID = t.TeamID
             JOIN Debates d ON (t.TeamID = d.Team1ID OR t.TeamID = d.Team2ID)
             JOIN Ballots b ON d.DebateID = b.DebateID
             JOIN SpeakerScores ss ON s.StudentID = ss.SpeakerID AND b.BallotID = ss.BallotID
             JOIN Schools sch ON s.SchoolID = sch.SchoolID
    WHERE d.TournamentID = $1 AND d.IsEliminationRound = false
    GROUP BY s.StudentID, StudentName, sch.SchoolName, t.TotalWins, t.TeamID
),
     TopThree AS (
         SELECT studentid, studentname, schoolname, totalwins, totalpoints, averagerank, place
         FROM RankedStudents
         WHERE place <= 3
     ),
     SearchResults AS (
         SELECT studentid, studentname, schoolname, totalwins, totalpoints, averagerank, place
         FROM RankedStudents
         WHERE $4::text IS NULL
            OR StudentName ILIKE '%' || $4 || '%'
            OR SchoolName ILIKE '%' || $4 || '%'
     )
SELECT DISTINCT ON (place) studentid, studentname, schoolname, totalwins, totalpoints, averagerank, place
FROM (
         SELECT studentid, studentname, schoolname, totalwins, totalpoints, averagerank, place FROM TopThree
         UNION
         SELECT studentid, studentname, schoolname, totalwins, totalpoints, averagerank, place FROM SearchResults WHERE place > 3
     ) combined
ORDER BY place
LIMIT $2 OFFSET $3
`

type GetTournamentStudentRankingParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Column4      string `json:"column_4"`
}

type GetTournamentStudentRankingRow struct {
	Studentid   int32         `json:"studentid"`
	Studentname interface{}   `json:"studentname"`
	Schoolname  string        `json:"schoolname"`
	Totalwins   sql.NullInt32 `json:"totalwins"`
	Totalpoints string        `json:"totalpoints"`
	Averagerank float64       `json:"averagerank"`
	Place       int64         `json:"place"`
}

func (q *Queries) GetTournamentStudentRanking(ctx context.Context, arg GetTournamentStudentRankingParams) ([]GetTournamentStudentRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentStudentRanking,
		arg.Tournamentid,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentStudentRankingRow{}
	for rows.Next() {
		var i GetTournamentStudentRankingRow
		if err := rows.Scan(
			&i.Studentid,
			&i.Studentname,
			&i.Schoolname,
			&i.Totalwins,
			&i.Totalpoints,
			&i.Averagerank,
			&i.Place,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentTeamsRanking = `-- name: GetTournamentTeamsRanking :many
WITH TeamData AS (
    SELECT
        t.TeamID,
        t.Name AS TeamName,
        t.TotalWins AS Wins,
        t.TotalSpeakerPoints AS TotalPoints,
        t.AverageRank,
        t.TournamentID
    FROM
        Teams t
    WHERE
        t.TournamentID = $1
),
     TeamSchools AS (
         SELECT
             td.TeamID,
             td.TeamName,
             td.Wins,
             td.TotalPoints,
             td.AverageRank,
             ARRAY_AGG(DISTINCT s.SchoolName) FILTER (WHERE s.SchoolName IS NOT NULL) AS SchoolNames
         FROM
             TeamData td
                 LEFT JOIN TeamMembers tm ON td.TeamID = tm.TeamID
                 LEFT JOIN Students stu ON tm.StudentID = stu.StudentID
                 LEFT JOIN Schools s ON stu.SchoolID = s.SchoolID
         GROUP BY
             td.TeamID, td.TeamName, td.Wins, td.TotalPoints, td.AverageRank
     ),
     RankedTeams AS (
         SELECT
             TeamID,
             TeamName,
             SchoolNames,
             Wins,
             TotalPoints,
             AverageRank,
             RANK() OVER (ORDER BY Wins DESC, TotalPoints DESC, AverageRank ASC) as place
         FROM
             TeamSchools
     ),
     TopThree AS (
         SELECT teamid, teamname, schoolnames, wins, totalpoints, averagerank, place FROM RankedTeams WHERE place <= 3
     ),
     FilteredTeams AS (
         SELECT teamid, teamname, schoolnames, wins, totalpoints, averagerank, place FROM RankedTeams
         WHERE $4::text IS NULL
            OR TeamName ILIKE '%' || $4 || '%'
            OR EXISTS (
             SELECT 1
             FROM unnest(SchoolNames) AS school
             WHERE school ILIKE '%' || $4 || '%'
         )
     )
SELECT teamid, teamname, schoolnames, wins, totalpoints, averagerank, place FROM (
                  SELECT teamid, teamname, schoolnames, wins, totalpoints, averagerank, place FROM TopThree
                  UNION ALL
                  SELECT teamid, teamname, schoolnames, wins, totalpoints, averagerank, place FROM FilteredTeams WHERE place > 3
              ) combined
ORDER BY place
LIMIT $2 OFFSET $3
`

type GetTournamentTeamsRankingParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Column4      string `json:"column_4"`
}

type GetTournamentTeamsRankingRow struct {
	Teamid      int32          `json:"teamid"`
	Teamname    string         `json:"teamname"`
	Schoolnames interface{}    `json:"schoolnames"`
	Wins        sql.NullInt32  `json:"wins"`
	Totalpoints sql.NullString `json:"totalpoints"`
	Averagerank sql.NullString `json:"averagerank"`
	Place       int64          `json:"place"`
}

func (q *Queries) GetTournamentTeamsRanking(ctx context.Context, arg GetTournamentTeamsRankingParams) ([]GetTournamentTeamsRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentTeamsRanking,
		arg.Tournamentid,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentTeamsRankingRow{}
	for rows.Next() {
		var i GetTournamentTeamsRankingRow
		if err := rows.Scan(
			&i.Teamid,
			&i.Teamname,
			&i.Schoolnames,
			&i.Wins,
			&i.Totalpoints,
			&i.Averagerank,
			&i.Place,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentTeamsRankingCount = `-- name: GetTournamentTeamsRankingCount :one
SELECT COUNT(DISTINCT t.TeamID)
FROM Teams t
WHERE t.TournamentID = $1
`

func (q *Queries) GetTournamentTeamsRankingCount(ctx context.Context, tournamentid int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTournamentTeamsRankingCount, tournamentid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTournamentVolunteerRanking = `-- name: GetTournamentVolunteerRanking :many
WITH RankedVolunteers AS (
    SELECT
        v.VolunteerID,
        v.FirstName || ' ' || v.LastName AS VolunteerName,
        COUNT(DISTINCT CASE WHEN d.IsEliminationRound = false THEN d.DebateID END) as PreliminaryRounds,
        COUNT(DISTINCT CASE WHEN d.IsEliminationRound = true THEN d.DebateID END) as EliminationRounds,
        COALESCE(AVG(jf.AverageRating), 0) as AverageRating,
        RANK() OVER (
            ORDER BY
                COALESCE(AVG(jf.AverageRating), 0) DESC,
                COUNT(DISTINCT CASE WHEN d.IsEliminationRound = true THEN d.DebateID END) DESC,
                COUNT(DISTINCT CASE WHEN d.IsEliminationRound = false THEN d.DebateID END) DESC
            ) as place
    FROM Volunteers v
             JOIN JudgeAssignments ja ON v.UserID = ja.JudgeID
             JOIN Debates d ON ja.DebateID = d.DebateID
             LEFT JOIN JudgeFeedback jf ON v.UserID = jf.JudgeID AND jf.DebateID = d.DebateID
    WHERE d.TournamentID = $1
    GROUP BY v.VolunteerID, v.FirstName, v.LastName
),
     TopThree AS (
         SELECT volunteerid, volunteername, preliminaryrounds, eliminationrounds, averagerating, place
         FROM RankedVolunteers
         WHERE place <= 3
     ),
     SearchResults AS (
         SELECT volunteerid, volunteername, preliminaryrounds, eliminationrounds, averagerating, place
         FROM RankedVolunteers
         WHERE $4::text IS NULL
            OR VolunteerName ILIKE '%' || $4 || '%'
     )
SELECT DISTINCT ON (place) volunteerid, volunteername, preliminaryrounds, eliminationrounds, averagerating, place
FROM (
         SELECT volunteerid, volunteername, preliminaryrounds, eliminationrounds, averagerating, place FROM TopThree
         UNION
         SELECT volunteerid, volunteername, preliminaryrounds, eliminationrounds, averagerating, place FROM SearchResults WHERE place > 3
     ) combined
ORDER BY place
LIMIT $2 OFFSET $3
`

type GetTournamentVolunteerRankingParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	Column4      string `json:"column_4"`
}

type GetTournamentVolunteerRankingRow struct {
	Volunteerid       int32       `json:"volunteerid"`
	Volunteername     interface{} `json:"volunteername"`
	Preliminaryrounds int64       `json:"preliminaryrounds"`
	Eliminationrounds int64       `json:"eliminationrounds"`
	Averagerating     interface{} `json:"averagerating"`
	Place             int64       `json:"place"`
}

func (q *Queries) GetTournamentVolunteerRanking(ctx context.Context, arg GetTournamentVolunteerRankingParams) ([]GetTournamentVolunteerRankingRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentVolunteerRanking,
		arg.Tournamentid,
		arg.Limit,
		arg.Offset,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentVolunteerRankingRow{}
	for rows.Next() {
		var i GetTournamentVolunteerRankingRow
		if err := rows.Scan(
			&i.Volunteerid,
			&i.Volunteername,
			&i.Preliminaryrounds,
			&i.Eliminationrounds,
			&i.Averagerating,
			&i.Place,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentVolunteerRankingCount = `-- name: GetTournamentVolunteerRankingCount :one
SELECT COUNT(DISTINCT v.VolunteerID)
FROM Volunteers v
JOIN JudgeAssignments ja ON v.UserID = ja.JudgeID
JOIN Debates d ON ja.DebateID = d.DebateID
WHERE d.TournamentID = $1
`

func (q *Queries) GetTournamentVolunteerRankingCount(ctx context.Context, tournamentid int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTournamentVolunteerRankingCount, tournamentid)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getVolunteerPerformance = `-- name: GetVolunteerPerformance :many
WITH tournament_performance AS (
    SELECT
        t.StartDate,
        v.UserID,
        AVG(jf.AverageRating) as VolunteerAverageRating,
        AVG(AVG(jf.AverageRating)) OVER (PARTITION BY d.TournamentID) as OverallAverageRating,
        RANK() OVER (PARTITION BY d.TournamentID ORDER BY AVG(jf.AverageRating) DESC) as TournamentRank
    FROM
        Volunteers v
        JOIN JudgeAssignments ja ON v.UserID = ja.JudgeID
        JOIN Debates d ON ja.DebateID = d.DebateID
        JOIN JudgeFeedback jf ON v.UserID = jf.JudgeID
        JOIN Tournaments t ON d.TournamentID = t.TournamentID
    WHERE
        v.UserID = $1 AND t.StartDate BETWEEN $2 AND $3
    GROUP BY
        t.StartDate, d.TournamentID, v.UserID
)
SELECT startdate, userid, volunteeraveragerating, overallaveragerating, tournamentrank
FROM tournament_performance
ORDER BY StartDate
`

type GetVolunteerPerformanceParams struct {
	Userid      int32     `json:"userid"`
	Startdate   time.Time `json:"startdate"`
	Startdate_2 time.Time `json:"startdate_2"`
}

type GetVolunteerPerformanceRow struct {
	Startdate              time.Time `json:"startdate"`
	Userid                 int32     `json:"userid"`
	Volunteeraveragerating float64   `json:"volunteeraveragerating"`
	Overallaveragerating   float64   `json:"overallaveragerating"`
	Tournamentrank         int64     `json:"tournamentrank"`
}

func (q *Queries) GetVolunteerPerformance(ctx context.Context, arg GetVolunteerPerformanceParams) ([]GetVolunteerPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getVolunteerPerformance, arg.Userid, arg.Startdate, arg.Startdate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVolunteerPerformanceRow{}
	for rows.Next() {
		var i GetVolunteerPerformanceRow
		if err := rows.Scan(
			&i.Startdate,
			&i.Userid,
			&i.Volunteeraveragerating,
			&i.Overallaveragerating,
			&i.Tournamentrank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVolunteerTournamentStats = `-- name: GetVolunteerTournamentStats :one
WITH volunteer_stats AS (
    SELECT
        COUNT(DISTINCT CASE WHEN d.DebateID IS NOT NULL THEN d.DebateID END) AS total_rounds_judged,
        COUNT(DISTINCT CASE WHEN t.TournamentID IS NOT NULL THEN t.TournamentID END) AS attended_tournaments,
        (
            SELECT COUNT(*)
            FROM TournamentInvitations ti
            JOIN Tournaments t ON ti.TournamentID = t.TournamentID
            JOIN Volunteers v2 ON ti.InviteeID = v2.iDebateVolunteerID
            WHERE v2.UserID = $1
            AND ti.Status = 'accepted'
            AND t.StartDate > CURRENT_DATE
        ) AS upcoming_tournaments
    FROM
        Volunteers v
        LEFT JOIN JudgeAssignments ja ON v.UserID = ja.JudgeID
        LEFT JOIN Debates d ON ja.DebateID = d.DebateID
        LEFT JOIN Tournaments t ON d.TournamentID = t.TournamentID
    WHERE
        v.UserID = $1
    GROUP BY v.UserID
)
SELECT
    vs.total_rounds_judged, vs.attended_tournaments, vs.upcoming_tournaments,
    COALESCE(v.yesterday_rounds_judged, 0) as yesterday_rounds_judged,
    COALESCE(v.yesterday_tournaments_attended, 0) as yesterday_tournaments_attended,
    COALESCE(v.yesterday_upcoming_tournaments, 0) as yesterday_upcoming_tournaments
FROM volunteer_stats vs
JOIN Volunteers v ON v.UserID = $1
`

type GetVolunteerTournamentStatsRow struct {
	TotalRoundsJudged            int64 `json:"total_rounds_judged"`
	AttendedTournaments          int64 `json:"attended_tournaments"`
	UpcomingTournaments          int64 `json:"upcoming_tournaments"`
	YesterdayRoundsJudged        int32 `json:"yesterday_rounds_judged"`
	YesterdayTournamentsAttended int32 `json:"yesterday_tournaments_attended"`
	YesterdayUpcomingTournaments int32 `json:"yesterday_upcoming_tournaments"`
}

func (q *Queries) GetVolunteerTournamentStats(ctx context.Context, userid int32) (GetVolunteerTournamentStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getVolunteerTournamentStats, userid)
	var i GetVolunteerTournamentStatsRow
	err := row.Scan(
		&i.TotalRoundsJudged,
		&i.AttendedTournaments,
		&i.UpcomingTournaments,
		&i.YesterdayRoundsJudged,
		&i.YesterdayTournamentsAttended,
		&i.YesterdayUpcomingTournaments,
	)
	return i, err
}

const insertTeamScore = `-- name: InsertTeamScore :exec
INSERT INTO TeamScores (TeamID, DebateID, TotalScore, IsElimination)
SELECT $1, $2, $3, $4
WHERE NOT EXISTS (
    SELECT 1 FROM TeamScores
    WHERE TeamID = $1 AND DebateID = $2
)
`

type InsertTeamScoreParams struct {
	Teamid        sql.NullInt32  `json:"teamid"`
	Debateid      sql.NullInt32  `json:"debateid"`
	Totalscore    sql.NullString `json:"totalscore"`
	Iselimination sql.NullBool   `json:"iselimination"`
}

func (q *Queries) InsertTeamScore(ctx context.Context, arg InsertTeamScoreParams) error {
	_, err := q.db.ExecContext(ctx, insertTeamScore,
		arg.Teamid,
		arg.Debateid,
		arg.Totalscore,
		arg.Iselimination,
	)
	return err
}

const isHeadJudgeForBallot = `-- name: IsHeadJudgeForBallot :one
SELECT COUNT(*) > 0 as is_head_judge
FROM Ballots b
JOIN Debates d ON b.DebateID = d.DebateID
JOIN JudgeAssignments ja ON d.DebateID = ja.DebateID
WHERE b.BallotID = $1 AND ja.JudgeID = $2 AND ja.IsHeadJudge = true
`

type IsHeadJudgeForBallotParams struct {
	Ballotid int32 `json:"ballotid"`
	Judgeid  int32 `json:"judgeid"`
}

func (q *Queries) IsHeadJudgeForBallot(ctx context.Context, arg IsHeadJudgeForBallotParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isHeadJudgeForBallot, arg.Ballotid, arg.Judgeid)
	var is_head_judge bool
	err := row.Scan(&is_head_judge)
	return is_head_judge, err
}

const markJudgeFeedbackAsRead = `-- name: MarkJudgeFeedbackAsRead :exec
UPDATE JudgeFeedback
SET IsRead = true
WHERE FeedbackID = $1 AND JudgeID = $2
`

type MarkJudgeFeedbackAsReadParams struct {
	Feedbackid int32         `json:"feedbackid"`
	Judgeid    sql.NullInt32 `json:"judgeid"`
}

func (q *Queries) MarkJudgeFeedbackAsRead(ctx context.Context, arg MarkJudgeFeedbackAsReadParams) error {
	_, err := q.db.ExecContext(ctx, markJudgeFeedbackAsRead, arg.Feedbackid, arg.Judgeid)
	return err
}

const markStudentFeedbackAsRead = `-- name: MarkStudentFeedbackAsRead :exec
UPDATE SpeakerScores
SET IsRead = true
WHERE SpeakerID = $1 AND BallotID = $2
`

type MarkStudentFeedbackAsReadParams struct {
	Speakerid int32 `json:"speakerid"`
	Ballotid  int32 `json:"ballotid"`
}

func (q *Queries) MarkStudentFeedbackAsRead(ctx context.Context, arg MarkStudentFeedbackAsReadParams) error {
	_, err := q.db.ExecContext(ctx, markStudentFeedbackAsRead, arg.Speakerid, arg.Ballotid)
	return err
}

const removeTeamMembers = `-- name: RemoveTeamMembers :exec
DELETE FROM TeamMembers
WHERE TeamID = $1
`

func (q *Queries) RemoveTeamMembers(ctx context.Context, teamid int32) error {
	_, err := q.db.ExecContext(ctx, removeTeamMembers, teamid)
	return err
}

const resetBallotAfterTeamChange = `-- name: ResetBallotAfterTeamChange :exec
UPDATE Ballots
SET Team1TotalScore = $2,
    Team2TotalScore = $3,
    RecordingStatus = $4,
    Verdict = $5,
    Team1Feedback = $6,
    Team2Feedback = $7,
    head_judge_submitted = $8,
    last_updated_at = CURRENT_TIMESTAMP
WHERE BallotID = $1
`

type ResetBallotAfterTeamChangeParams struct {
	Ballotid           int32          `json:"ballotid"`
	Team1totalscore    sql.NullString `json:"team1totalscore"`
	Team2totalscore    sql.NullString `json:"team2totalscore"`
	Recordingstatus    string         `json:"recordingstatus"`
	Verdict            string         `json:"verdict"`
	Team1feedback      sql.NullString `json:"team1feedback"`
	Team2feedback      sql.NullString `json:"team2feedback"`
	HeadJudgeSubmitted sql.NullBool   `json:"head_judge_submitted"`
}

func (q *Queries) ResetBallotAfterTeamChange(ctx context.Context, arg ResetBallotAfterTeamChangeParams) error {
	_, err := q.db.ExecContext(ctx, resetBallotAfterTeamChange,
		arg.Ballotid,
		arg.Team1totalscore,
		arg.Team2totalscore,
		arg.Recordingstatus,
		arg.Verdict,
		arg.Team1feedback,
		arg.Team2feedback,
		arg.HeadJudgeSubmitted,
	)
	return err
}

const setRankingVisibility = `-- name: SetRankingVisibility :exec
INSERT INTO RankingVisibility (TournamentID, RankingType, VisibleTo, IsVisible)
VALUES ($1, $2, $3, $4)
ON CONFLICT (TournamentID, RankingType, VisibleTo)
    DO UPDATE SET IsVisible = $4, UpdatedAt = CURRENT_TIMESTAMP
`

type SetRankingVisibilityParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Rankingtype  string `json:"rankingtype"`
	Visibleto    string `json:"visibleto"`
	Isvisible    bool   `json:"isvisible"`
}

func (q *Queries) SetRankingVisibility(ctx context.Context, arg SetRankingVisibilityParams) error {
	_, err := q.db.ExecContext(ctx, setRankingVisibility,
		arg.Tournamentid,
		arg.Rankingtype,
		arg.Visibleto,
		arg.Isvisible,
	)
	return err
}

const teamHasDebates = `-- name: TeamHasDebates :one
SELECT EXISTS (
    SELECT 1 FROM Debates
    WHERE Team1ID = $1 OR Team2ID = $1
) AS has_debates
`

func (q *Queries) TeamHasDebates(ctx context.Context, team1id int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, teamHasDebates, team1id)
	var has_debates bool
	err := row.Scan(&has_debates)
	return has_debates, err
}

const updateBallot = `-- name: UpdateBallot :exec
UPDATE Ballots
SET Team1TotalScore = $2, Team2TotalScore = $3, RecordingStatus = $4, Verdict = $5,
    Team1Feedback = $6, Team2Feedback = $7, last_updated_by = $8,
    last_updated_at = CURRENT_TIMESTAMP, head_judge_submitted = $9
WHERE BallotID = $1
`

type UpdateBallotParams struct {
	Ballotid           int32          `json:"ballotid"`
	Team1totalscore    sql.NullString `json:"team1totalscore"`
	Team2totalscore    sql.NullString `json:"team2totalscore"`
	Recordingstatus    string         `json:"recordingstatus"`
	Verdict            string         `json:"verdict"`
	Team1feedback      sql.NullString `json:"team1feedback"`
	Team2feedback      sql.NullString `json:"team2feedback"`
	LastUpdatedBy      sql.NullInt32  `json:"last_updated_by"`
	HeadJudgeSubmitted sql.NullBool   `json:"head_judge_submitted"`
}

func (q *Queries) UpdateBallot(ctx context.Context, arg UpdateBallotParams) error {
	_, err := q.db.ExecContext(ctx, updateBallot,
		arg.Ballotid,
		arg.Team1totalscore,
		arg.Team2totalscore,
		arg.Recordingstatus,
		arg.Verdict,
		arg.Team1feedback,
		arg.Team2feedback,
		arg.LastUpdatedBy,
		arg.HeadJudgeSubmitted,
	)
	return err
}

const updateJudgeRoom = `-- name: UpdateJudgeRoom :exec
WITH new_debate AS (
    SELECT d.DebateID
    FROM Debates d
    WHERE d.TournamentID = $2
    AND d.RoundNumber = $3
    AND d.RoomID = $4
    AND d.IsEliminationRound = $5
),
old_assignment AS (
    SELECT ja.DebateID, ja.IsHeadJudge
    FROM JudgeAssignments ja
    JOIN Debates d ON ja.DebateID = d.DebateID
    WHERE ja.JudgeID = $1
    AND d.TournamentID = $2
    AND d.RoundNumber = $3
    AND d.IsEliminationRound = $5
)
UPDATE JudgeAssignments ja
SET DebateID = nd.DebateID
FROM new_debate nd, old_assignment oa
WHERE ja.JudgeID = $1
AND ja.TournamentID = $2
AND ja.DebateID = oa.DebateID
AND nd.DebateID IS NOT NULL
`

type UpdateJudgeRoomParams struct {
	Judgeid            int32 `json:"judgeid"`
	Tournamentid       int32 `json:"tournamentid"`
	Roundnumber        int32 `json:"roundnumber"`
	Roomid             int32 `json:"roomid"`
	Iseliminationround bool  `json:"iseliminationround"`
}

func (q *Queries) UpdateJudgeRoom(ctx context.Context, arg UpdateJudgeRoomParams) error {
	_, err := q.db.ExecContext(ctx, updateJudgeRoom,
		arg.Judgeid,
		arg.Tournamentid,
		arg.Roundnumber,
		arg.Roomid,
		arg.Iseliminationround,
	)
	return err
}

const updatePairing = `-- name: UpdatePairing :exec
UPDATE Debates
SET Team1ID = $2, Team2ID = $3
WHERE DebateID = $1
`

type UpdatePairingParams struct {
	Debateid int32 `json:"debateid"`
	Team1id  int32 `json:"team1id"`
	Team2id  int32 `json:"team2id"`
}

func (q *Queries) UpdatePairing(ctx context.Context, arg UpdatePairingParams) error {
	_, err := q.db.ExecContext(ctx, updatePairing, arg.Debateid, arg.Team1id, arg.Team2id)
	return err
}

const updateRoom = `-- name: UpdateRoom :one
UPDATE Rooms
SET RoomName = $2
WHERE RoomID = $1
RETURNING roomid, roomname, location, capacity, tournamentid
`

type UpdateRoomParams struct {
	Roomid   int32  `json:"roomid"`
	Roomname string `json:"roomname"`
}

func (q *Queries) UpdateRoom(ctx context.Context, arg UpdateRoomParams) (Room, error) {
	row := q.db.QueryRowContext(ctx, updateRoom, arg.Roomid, arg.Roomname)
	var i Room
	err := row.Scan(
		&i.Roomid,
		&i.Roomname,
		&i.Location,
		&i.Capacity,
		&i.Tournamentid,
	)
	return i, err
}

const updateSpeakerScore = `-- name: UpdateSpeakerScore :exec
UPDATE SpeakerScores
SET SpeakerRank = $3, SpeakerPoints = $4, Feedback = $5
WHERE BallotID = $1 AND SpeakerID = $2
`

type UpdateSpeakerScoreParams struct {
	Ballotid      int32          `json:"ballotid"`
	Speakerid     int32          `json:"speakerid"`
	Speakerrank   int32          `json:"speakerrank"`
	Speakerpoints string         `json:"speakerpoints"`
	Feedback      sql.NullString `json:"feedback"`
}

func (q *Queries) UpdateSpeakerScore(ctx context.Context, arg UpdateSpeakerScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateSpeakerScore,
		arg.Ballotid,
		arg.Speakerid,
		arg.Speakerrank,
		arg.Speakerpoints,
		arg.Feedback,
	)
	return err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE Teams
SET Name = $2
WHERE TeamID = $1
`

type UpdateTeamParams struct {
	Teamid int32  `json:"teamid"`
	Name   string `json:"name"`
}

func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.db.ExecContext(ctx, updateTeam, arg.Teamid, arg.Name)
	return err
}

const updateTeamScore = `-- name: UpdateTeamScore :exec
UPDATE TeamScores
SET TotalScore = $3, IsElimination = $4
WHERE TeamID = $1 AND DebateID = $2
`

type UpdateTeamScoreParams struct {
	Teamid        sql.NullInt32  `json:"teamid"`
	Debateid      sql.NullInt32  `json:"debateid"`
	Totalscore    sql.NullString `json:"totalscore"`
	Iselimination sql.NullBool   `json:"iselimination"`
}

func (q *Queries) UpdateTeamScore(ctx context.Context, arg UpdateTeamScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateTeamScore,
		arg.Teamid,
		arg.Debateid,
		arg.Totalscore,
		arg.Iselimination,
	)
	return err
}

const updateTeamScoreRank = `-- name: UpdateTeamScoreRank :exec
UPDATE TeamScores
SET Rank = $3
WHERE TeamID = $1 AND DebateID = $2
`

type UpdateTeamScoreRankParams struct {
	Teamid   sql.NullInt32 `json:"teamid"`
	Debateid sql.NullInt32 `json:"debateid"`
	Rank     sql.NullInt32 `json:"rank"`
}

func (q *Queries) UpdateTeamScoreRank(ctx context.Context, arg UpdateTeamScoreRankParams) error {
	_, err := q.db.ExecContext(ctx, updateTeamScoreRank, arg.Teamid, arg.Debateid, arg.Rank)
	return err
}

const updateTeamStats = `-- name: UpdateTeamStats :exec
WITH team_stats AS (
    SELECT
        t.TeamID,
        t.TournamentID,
        COUNT(CASE WHEN b.Verdict = t.Name THEN 1 ELSE NULL END) AS TotalWins,
        AVG(ts.Rank) AS AvgRank,
        SUM(ts.TotalScore::NUMERIC) AS TotalSpeakerPoints
    FROM
        Teams t
    JOIN
        Debates d ON (t.TeamID = d.Team1ID OR t.TeamID = d.Team2ID) AND t.TournamentID = d.TournamentID
    JOIN
        Ballots b ON d.DebateID = b.DebateID
    JOIN
        TeamScores ts ON t.TeamID = ts.TeamID AND d.DebateID = ts.DebateID
    WHERE
        t.TeamID = $1 AND t.TournamentID = $2
    GROUP BY
        t.TeamID, t.TournamentID
)
UPDATE Teams
SET
    TotalWins = team_stats.TotalWins,
    AverageRank = team_stats.AvgRank,
    TotalSpeakerPoints = team_stats.TotalSpeakerPoints
FROM
    team_stats
WHERE
    Teams.TeamID = team_stats.TeamID AND Teams.TournamentID = team_stats.TournamentID
`

type UpdateTeamStatsParams struct {
	Teamid       int32 `json:"teamid"`
	Tournamentid int32 `json:"tournamentid"`
}

func (q *Queries) UpdateTeamStats(ctx context.Context, arg UpdateTeamStatsParams) error {
	_, err := q.db.ExecContext(ctx, updateTeamStats, arg.Teamid, arg.Tournamentid)
	return err
}
