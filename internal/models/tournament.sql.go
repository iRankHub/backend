// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tournament.sql

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const bulkUpdateInvitationStatus = `-- name: BulkUpdateInvitationStatus :many
UPDATE TournamentInvitations
SET Status = $2, updated_at = CURRENT_TIMESTAMP
WHERE InvitationID = ANY($1::int[])
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type BulkUpdateInvitationStatusParams struct {
	Column1 []int32 `json:"column_1"`
	Status  string  `json:"status"`
}

func (q *Queries) BulkUpdateInvitationStatus(ctx context.Context, arg BulkUpdateInvitationStatusParams) ([]Tournamentinvitation, error) {
	rows, err := q.db.QueryContext(ctx, bulkUpdateInvitationStatus, pq.Array(arg.Column1), arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournamentinvitation{}
	for rows.Next() {
		var i Tournamentinvitation
		if err := rows.Scan(
			&i.Invitationid,
			&i.Tournamentid,
			&i.Inviteeid,
			&i.Inviteerole,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Remindersentat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO TournamentInvitations (TournamentID, InviteeID, InviteeRole, Status)
VALUES ($1, $2, $3, $4)
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type CreateInvitationParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Inviteeid    string `json:"inviteeid"`
	Inviteerole  string `json:"inviteerole"`
	Status       string `json:"status"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, createInvitation,
		arg.Tournamentid,
		arg.Inviteeid,
		arg.Inviteerole,
		arg.Status,
	)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one
INSERT INTO Leagues (Name, LeagueType, Details)
VALUES ($1, $2, $3)
RETURNING leagueid, name, leaguetype, details, deleted_at
`

type CreateLeagueParams struct {
	Name       string          `json:"name"`
	Leaguetype string          `json:"leaguetype"`
	Details    json.RawMessage `json:"details"`
}

// League Queries
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.db.QueryRowContext(ctx, createLeague, arg.Name, arg.Leaguetype, arg.Details)
	var i League
	err := row.Scan(
		&i.Leagueid,
		&i.Name,
		&i.Leaguetype,
		&i.Details,
		&i.DeletedAt,
	)
	return i, err
}

const createSchoolRegistration = `-- name: CreateSchoolRegistration :one
INSERT INTO SchoolTournamentRegistrations (
    SchoolID, TournamentID, PlannedTeamsCount,
    AmountPerTeam, Currency, CreatedBy
)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING registrationid, schoolid, tournamentid, plannedteamscount, actualteamscount, amountperteam, totalamount, discountamount, actualpaidamount, paymentstatus, paymentdate, currency, createdat, updatedat, createdby, updatedby
`

type CreateSchoolRegistrationParams struct {
	Schoolid          int32         `json:"schoolid"`
	Tournamentid      int32         `json:"tournamentid"`
	Plannedteamscount int32         `json:"plannedteamscount"`
	Amountperteam     string        `json:"amountperteam"`
	Currency          string        `json:"currency"`
	Createdby         sql.NullInt32 `json:"createdby"`
}

func (q *Queries) CreateSchoolRegistration(ctx context.Context, arg CreateSchoolRegistrationParams) (Schooltournamentregistration, error) {
	row := q.db.QueryRowContext(ctx, createSchoolRegistration,
		arg.Schoolid,
		arg.Tournamentid,
		arg.Plannedteamscount,
		arg.Amountperteam,
		arg.Currency,
		arg.Createdby,
	)
	var i Schooltournamentregistration
	err := row.Scan(
		&i.Registrationid,
		&i.Schoolid,
		&i.Tournamentid,
		&i.Plannedteamscount,
		&i.Actualteamscount,
		&i.Amountperteam,
		&i.Totalamount,
		&i.Discountamount,
		&i.Actualpaidamount,
		&i.Paymentstatus,
		&i.Paymentdate,
		&i.Currency,
		&i.Createdat,
		&i.Updatedat,
		&i.Createdby,
		&i.Updatedby,
	)
	return i, err
}

const createTournamentEntry = `-- name: CreateTournamentEntry :one
INSERT INTO Tournaments (Name, StartDate, EndDate, Location, FormatID, LeagueID, CoordinatorID, NumberOfPreliminaryRounds, NumberOfEliminationRounds, JudgesPerDebatePreliminary, JudgesPerDebateElimination, TournamentFee, ImageUrl)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING tournamentid, name, startdate, enddate, location, formatid, leagueid, coordinatorid, numberofpreliminaryrounds, numberofeliminationrounds, judgesperdebatepreliminary, judgesperdebateelimination, tournamentfee, imageurl, created_at, updated_at, deleted_at, yesterday_total_count, yesterday_upcoming_count, yesterday_active_debaters_count
`

type CreateTournamentEntryParams struct {
	Name                       string         `json:"name"`
	Startdate                  time.Time      `json:"startdate"`
	Enddate                    time.Time      `json:"enddate"`
	Location                   string         `json:"location"`
	Formatid                   int32          `json:"formatid"`
	Leagueid                   sql.NullInt32  `json:"leagueid"`
	Coordinatorid              int32          `json:"coordinatorid"`
	Numberofpreliminaryrounds  int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32          `json:"judgesperdebateelimination"`
	Tournamentfee              string         `json:"tournamentfee"`
	Imageurl                   sql.NullString `json:"imageurl"`
}

// Tournament Queries
func (q *Queries) CreateTournamentEntry(ctx context.Context, arg CreateTournamentEntryParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, createTournamentEntry,
		arg.Name,
		arg.Startdate,
		arg.Enddate,
		arg.Location,
		arg.Formatid,
		arg.Leagueid,
		arg.Coordinatorid,
		arg.Numberofpreliminaryrounds,
		arg.Numberofeliminationrounds,
		arg.Judgesperdebatepreliminary,
		arg.Judgesperdebateelimination,
		arg.Tournamentfee,
		arg.Imageurl,
	)
	var i Tournament
	err := row.Scan(
		&i.Tournamentid,
		&i.Name,
		&i.Startdate,
		&i.Enddate,
		&i.Location,
		&i.Formatid,
		&i.Leagueid,
		&i.Coordinatorid,
		&i.Numberofpreliminaryrounds,
		&i.Numberofeliminationrounds,
		&i.Judgesperdebatepreliminary,
		&i.Judgesperdebateelimination,
		&i.Tournamentfee,
		&i.Imageurl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
		&i.YesterdayActiveDebatersCount,
	)
	return i, err
}

const createTournamentExpenses = `-- name: CreateTournamentExpenses :one
INSERT INTO TournamentExpenses (
    TournamentID, FoodExpense, TransportExpense, PerDiemExpense,
    AwardingExpense, StationaryExpense, OtherExpenses, Currency,
    Notes, CreatedBy
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING expenseid, tournamentid, foodexpense, transportexpense, perdiemexpense, awardingexpense, stationaryexpense, otherexpenses, totalexpense, currency, notes, createdat, updatedat, createdby, updatedby
`

type CreateTournamentExpensesParams struct {
	Tournamentid      int32          `json:"tournamentid"`
	Foodexpense       string         `json:"foodexpense"`
	Transportexpense  string         `json:"transportexpense"`
	Perdiemexpense    string         `json:"perdiemexpense"`
	Awardingexpense   string         `json:"awardingexpense"`
	Stationaryexpense string         `json:"stationaryexpense"`
	Otherexpenses     string         `json:"otherexpenses"`
	Currency          string         `json:"currency"`
	Notes             sql.NullString `json:"notes"`
	Createdby         sql.NullInt32  `json:"createdby"`
}

func (q *Queries) CreateTournamentExpenses(ctx context.Context, arg CreateTournamentExpensesParams) (Tournamentexpense, error) {
	row := q.db.QueryRowContext(ctx, createTournamentExpenses,
		arg.Tournamentid,
		arg.Foodexpense,
		arg.Transportexpense,
		arg.Perdiemexpense,
		arg.Awardingexpense,
		arg.Stationaryexpense,
		arg.Otherexpenses,
		arg.Currency,
		arg.Notes,
		arg.Createdby,
	)
	var i Tournamentexpense
	err := row.Scan(
		&i.Expenseid,
		&i.Tournamentid,
		&i.Foodexpense,
		&i.Transportexpense,
		&i.Perdiemexpense,
		&i.Awardingexpense,
		&i.Stationaryexpense,
		&i.Otherexpenses,
		&i.Totalexpense,
		&i.Currency,
		&i.Notes,
		&i.Createdat,
		&i.Updatedat,
		&i.Createdby,
		&i.Updatedby,
	)
	return i, err
}

const createTournamentFormat = `-- name: CreateTournamentFormat :one
INSERT INTO TournamentFormats (FormatName, Description, SpeakersPerTeam)
VALUES ($1, $2, $3)
RETURNING formatid, formatname, description, speakersperteam, deleted_at
`

type CreateTournamentFormatParams struct {
	Formatname      string         `json:"formatname"`
	Description     sql.NullString `json:"description"`
	Speakersperteam int32          `json:"speakersperteam"`
}

// Tournament Format Queries
func (q *Queries) CreateTournamentFormat(ctx context.Context, arg CreateTournamentFormatParams) (Tournamentformat, error) {
	row := q.db.QueryRowContext(ctx, createTournamentFormat, arg.Formatname, arg.Description, arg.Speakersperteam)
	var i Tournamentformat
	err := row.Scan(
		&i.Formatid,
		&i.Formatname,
		&i.Description,
		&i.Speakersperteam,
		&i.DeletedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM TournamentInvitations WHERE InvitationID = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, invitationid int32) error {
	_, err := q.db.ExecContext(ctx, deleteInvitation, invitationid)
	return err
}

const deleteLeagueByID = `-- name: DeleteLeagueByID :exec
UPDATE Leagues
SET deleted_at = CURRENT_TIMESTAMP
WHERE LeagueID = $1
`

func (q *Queries) DeleteLeagueByID(ctx context.Context, leagueid int32) error {
	_, err := q.db.ExecContext(ctx, deleteLeagueByID, leagueid)
	return err
}

const deleteTournamentByID = `-- name: DeleteTournamentByID :exec
UPDATE Tournaments
SET deleted_at = CURRENT_TIMESTAMP
WHERE TournamentID = $1
`

func (q *Queries) DeleteTournamentByID(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deleteTournamentByID, tournamentid)
	return err
}

const deleteTournamentFormatByID = `-- name: DeleteTournamentFormatByID :exec
UPDATE TournamentFormats
SET deleted_at = CURRENT_TIMESTAMP
WHERE FormatID = $1
`

func (q *Queries) DeleteTournamentFormatByID(ctx context.Context, formatid int32) error {
	_, err := q.db.ExecContext(ctx, deleteTournamentFormatByID, formatid)
	return err
}

const getActiveTournaments = `-- name: GetActiveTournaments :many
SELECT tournamentid, name, startdate, enddate, location, formatid, leagueid, coordinatorid, numberofpreliminaryrounds, numberofeliminationrounds, judgesperdebatepreliminary, judgesperdebateelimination, tournamentfee, imageurl, created_at, updated_at, deleted_at, yesterday_total_count, yesterday_upcoming_count, yesterday_active_debaters_count FROM Tournaments
WHERE StartDate > CURRENT_TIMESTAMP
  AND deleted_at IS NULL
ORDER BY StartDate
`

func (q *Queries) GetActiveTournaments(ctx context.Context) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.Tournamentid,
			&i.Name,
			&i.Startdate,
			&i.Enddate,
			&i.Location,
			&i.Formatid,
			&i.Leagueid,
			&i.Coordinatorid,
			&i.Numberofpreliminaryrounds,
			&i.Numberofeliminationrounds,
			&i.Judgesperdebatepreliminary,
			&i.Judgesperdebateelimination,
			&i.Tournamentfee,
			&i.Imageurl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.YesterdayTotalCount,
			&i.YesterdayUpcomingCount,
			&i.YesterdayActiveDebatersCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat FROM TournamentInvitations WHERE InvitationID = $1
`

func (q *Queries) GetInvitationByID(ctx context.Context, invitationid int32) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByID, invitationid)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const getInvitationsByTournament = `-- name: GetInvitationsByTournament :many
SELECT
    ti.InvitationID,
    ti.Status,
    ti.InviteeID,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.SchoolName
        WHEN ti.InviteeRole = 'volunteer' THEN CONCAT(v.FirstName, ' ', v.LastName)
        WHEN ti.InviteeRole = 'student' THEN CONCAT(st.FirstName, ' ', st.LastName)
    END as InviteeName,
    ti.InviteeRole,
    ti.created_at,
    ti.updated_at
FROM
    TournamentInvitations ti
LEFT JOIN
    Schools s ON ti.InviteeID = s.iDebateSchoolID
LEFT JOIN
    Volunteers v ON ti.InviteeID = v.iDebateVolunteerID
LEFT JOIN
    Students st ON ti.InviteeID = st.iDebateStudentID
WHERE
    ti.TournamentID = $1
ORDER BY
    ti.created_at DESC
`

type GetInvitationsByTournamentRow struct {
	Invitationid int32        `json:"invitationid"`
	Status       string       `json:"status"`
	Inviteeid    string       `json:"inviteeid"`
	Inviteename  interface{}  `json:"inviteename"`
	Inviteerole  string       `json:"inviteerole"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetInvitationsByTournament(ctx context.Context, tournamentid int32) ([]GetInvitationsByTournamentRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByTournament, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByTournamentRow{}
	for rows.Next() {
		var i GetInvitationsByTournamentRow
		if err := rows.Scan(
			&i.Invitationid,
			&i.Status,
			&i.Inviteeid,
			&i.Inviteename,
			&i.Inviteerole,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsByUser = `-- name: GetInvitationsByUser :many
SELECT
    ti.invitationid, ti.tournamentid, ti.inviteeid, ti.inviteerole, ti.status, ti.created_at, ti.updated_at, ti.remindersentat,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.SchoolName
        WHEN ti.InviteeRole = 'volunteer' THEN CONCAT(v.FirstName, ' ', v.LastName)
        WHEN ti.InviteeRole = 'student' THEN CONCAT(st.FirstName, ' ', st.LastName)
    END AS InviteeName
FROM TournamentInvitations ti
LEFT JOIN Schools s ON ti.InviteeRole = 'school' AND ti.InviteeID = s.iDebateSchoolID
LEFT JOIN Volunteers v ON ti.InviteeRole = 'volunteer' AND ti.InviteeID = v.iDebateVolunteerID
LEFT JOIN Students st ON ti.InviteeRole = 'student' AND ti.InviteeID = st.iDebateStudentID
WHERE
    (ti.InviteeRole = 'school' AND s.ContactPersonID = $1) OR
    (ti.InviteeRole = 'volunteer' AND v.UserID = $1) OR
    (ti.InviteeRole = 'student' AND st.UserID = $1)
ORDER BY ti.created_at DESC
`

type GetInvitationsByUserRow struct {
	Invitationid   int32        `json:"invitationid"`
	Tournamentid   int32        `json:"tournamentid"`
	Inviteeid      string       `json:"inviteeid"`
	Inviteerole    string       `json:"inviteerole"`
	Status         string       `json:"status"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	Remindersentat sql.NullTime `json:"remindersentat"`
	Inviteename    interface{}  `json:"inviteename"`
}

func (q *Queries) GetInvitationsByUser(ctx context.Context, contactpersonid int32) ([]GetInvitationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByUser, contactpersonid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByUserRow{}
	for rows.Next() {
		var i GetInvitationsByUserRow
		if err := rows.Scan(
			&i.Invitationid,
			&i.Tournamentid,
			&i.Inviteeid,
			&i.Inviteerole,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Remindersentat,
			&i.Inviteename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueByID = `-- name: GetLeagueByID :one
SELECT leagueid, name, leaguetype, details, deleted_at FROM Leagues
WHERE LeagueID = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLeagueByID(ctx context.Context, leagueid int32) (League, error) {
	row := q.db.QueryRowContext(ctx, getLeagueByID, leagueid)
	var i League
	err := row.Scan(
		&i.Leagueid,
		&i.Name,
		&i.Leaguetype,
		&i.Details,
		&i.DeletedAt,
	)
	return i, err
}

const getPendingInvitations = `-- name: GetPendingInvitations :many
SELECT
    ti.invitationid, ti.tournamentid, ti.inviteeid, ti.inviteerole, ti.status, ti.created_at, ti.updated_at, ti.remindersentat,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.SchoolName
        WHEN ti.InviteeRole = 'volunteer' THEN CONCAT(v.FirstName, ' ', v.LastName)
        WHEN ti.InviteeRole = 'student' THEN CONCAT(st.FirstName, ' ', st.LastName)
    END as InviteeName,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.ContactEmail
        WHEN ti.InviteeRole = 'volunteer' THEN u.Email
        WHEN ti.InviteeRole = 'student' THEN st.Email
    END as InviteeEmail,
    t.Name as TournamentName,
    t.StartDate as TournamentStartDate,
    t.EndDate as TournamentEndDate,
    t.Location as TournamentLocation
FROM
    TournamentInvitations ti
JOIN
    Tournaments t ON ti.TournamentID = t.TournamentID
LEFT JOIN
    Schools s ON ti.InviteeRole = 'school' AND ti.InviteeID = s.iDebateSchoolID
LEFT JOIN
    Volunteers v ON ti.InviteeRole = 'volunteer' AND ti.InviteeID = v.iDebateVolunteerID
LEFT JOIN
    Students st ON ti.InviteeRole = 'student' AND ti.InviteeID = st.iDebateStudentID
LEFT JOIN
    Users u ON (ti.InviteeRole = 'volunteer' AND v.UserID = u.UserID)
WHERE
    ti.TournamentID = $1 AND ti.Status = 'pending'
ORDER BY
    ti.created_at DESC
`

type GetPendingInvitationsRow struct {
	Invitationid        int32        `json:"invitationid"`
	Tournamentid        int32        `json:"tournamentid"`
	Inviteeid           string       `json:"inviteeid"`
	Inviteerole         string       `json:"inviteerole"`
	Status              string       `json:"status"`
	CreatedAt           sql.NullTime `json:"created_at"`
	UpdatedAt           sql.NullTime `json:"updated_at"`
	Remindersentat      sql.NullTime `json:"remindersentat"`
	Inviteename         interface{}  `json:"inviteename"`
	Inviteeemail        interface{}  `json:"inviteeemail"`
	Tournamentname      string       `json:"tournamentname"`
	Tournamentstartdate time.Time    `json:"tournamentstartdate"`
	Tournamentenddate   time.Time    `json:"tournamentenddate"`
	Tournamentlocation  string       `json:"tournamentlocation"`
}

func (q *Queries) GetPendingInvitations(ctx context.Context, tournamentid int32) ([]GetPendingInvitationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingInvitations, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsRow{}
	for rows.Next() {
		var i GetPendingInvitationsRow
		if err := rows.Scan(
			&i.Invitationid,
			&i.Tournamentid,
			&i.Inviteeid,
			&i.Inviteerole,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Remindersentat,
			&i.Inviteename,
			&i.Inviteeemail,
			&i.Tournamentname,
			&i.Tournamentstartdate,
			&i.Tournamentenddate,
			&i.Tournamentlocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRegistrationCurrency = `-- name: GetRegistrationCurrency :one
SELECT
    CASE
        WHEN l.LeagueType = 'international' THEN 'USD'
        ELSE 'RWF'
    END as Currency
FROM Tournaments t
JOIN Leagues l ON t.LeagueID = l.LeagueID
WHERE t.TournamentID = $1
`

func (q *Queries) GetRegistrationCurrency(ctx context.Context, tournamentid int32) (string, error) {
	row := q.db.QueryRowContext(ctx, getRegistrationCurrency, tournamentid)
	var currency string
	err := row.Scan(&currency)
	return currency, err
}

const getSchoolRegistration = `-- name: GetSchoolRegistration :one
SELECT
    str.registrationid, str.schoolid, str.tournamentid, str.plannedteamscount, str.actualteamscount, str.amountperteam, str.totalamount, str.discountamount, str.actualpaidamount, str.paymentstatus, str.paymentdate, str.currency, str.createdat, str.updatedat, str.createdby, str.updatedby,
    s.SchoolName,
    s.SchoolEmail,
    s.SchoolType,
    s.ContactEmail,
    u.Name as ContactPersonName,
    s.Country,
    s.Province,
    s.District,
    s.Address
FROM SchoolTournamentRegistrations str
JOIN Schools s ON str.SchoolID = s.SchoolID
JOIN Users u ON s.ContactPersonID = u.UserID
WHERE str.SchoolID = $1 AND str.TournamentID = $2
`

type GetSchoolRegistrationParams struct {
	Schoolid     int32 `json:"schoolid"`
	Tournamentid int32 `json:"tournamentid"`
}

type GetSchoolRegistrationRow struct {
	Registrationid    int32          `json:"registrationid"`
	Schoolid          int32          `json:"schoolid"`
	Tournamentid      int32          `json:"tournamentid"`
	Plannedteamscount int32          `json:"plannedteamscount"`
	Actualteamscount  sql.NullInt32  `json:"actualteamscount"`
	Amountperteam     string         `json:"amountperteam"`
	Totalamount       sql.NullString `json:"totalamount"`
	Discountamount    sql.NullString `json:"discountamount"`
	Actualpaidamount  sql.NullString `json:"actualpaidamount"`
	Paymentstatus     string         `json:"paymentstatus"`
	Paymentdate       sql.NullTime   `json:"paymentdate"`
	Currency          string         `json:"currency"`
	Createdat         sql.NullTime   `json:"createdat"`
	Updatedat         sql.NullTime   `json:"updatedat"`
	Createdby         sql.NullInt32  `json:"createdby"`
	Updatedby         sql.NullInt32  `json:"updatedby"`
	Schoolname        string         `json:"schoolname"`
	Schoolemail       string         `json:"schoolemail"`
	Schooltype        string         `json:"schooltype"`
	Contactemail      string         `json:"contactemail"`
	Contactpersonname string         `json:"contactpersonname"`
	Country           sql.NullString `json:"country"`
	Province          sql.NullString `json:"province"`
	District          sql.NullString `json:"district"`
	Address           string         `json:"address"`
}

func (q *Queries) GetSchoolRegistration(ctx context.Context, arg GetSchoolRegistrationParams) (GetSchoolRegistrationRow, error) {
	row := q.db.QueryRowContext(ctx, getSchoolRegistration, arg.Schoolid, arg.Tournamentid)
	var i GetSchoolRegistrationRow
	err := row.Scan(
		&i.Registrationid,
		&i.Schoolid,
		&i.Tournamentid,
		&i.Plannedteamscount,
		&i.Actualteamscount,
		&i.Amountperteam,
		&i.Totalamount,
		&i.Discountamount,
		&i.Actualpaidamount,
		&i.Paymentstatus,
		&i.Paymentdate,
		&i.Currency,
		&i.Createdat,
		&i.Updatedat,
		&i.Createdby,
		&i.Updatedby,
		&i.Schoolname,
		&i.Schoolemail,
		&i.Schooltype,
		&i.Contactemail,
		&i.Contactpersonname,
		&i.Country,
		&i.Province,
		&i.District,
		&i.Address,
	)
	return i, err
}

const getTournamentByID = `-- name: GetTournamentByID :one
SELECT t.tournamentid, t.name, t.startdate, t.enddate, t.location, t.formatid, t.leagueid, t.coordinatorid, t.numberofpreliminaryrounds, t.numberofeliminationrounds, t.judgesperdebatepreliminary, t.judgesperdebateelimination, t.tournamentfee, t.imageurl, t.created_at, t.updated_at, t.deleted_at, t.yesterday_total_count, t.yesterday_upcoming_count, t.yesterday_active_debaters_count, tf.FormatName, tf.Description AS FormatDescription, tf.SpeakersPerTeam,
       l.Name AS LeagueName, l.LeagueType, l.Details AS LeagueDetails,
       u.Name AS CoordinatorName, u.UserID AS CoordinatorID
FROM Tournaments t
JOIN TournamentFormats tf ON t.FormatID = tf.FormatID
JOIN Leagues l ON t.LeagueID = l.LeagueID
JOIN Users u ON t.CoordinatorID = u.UserID
WHERE t.TournamentID = $1 AND t.deleted_at IS NULL
`

type GetTournamentByIDRow struct {
	Tournamentid                 int32           `json:"tournamentid"`
	Name                         string          `json:"name"`
	Startdate                    time.Time       `json:"startdate"`
	Enddate                      time.Time       `json:"enddate"`
	Location                     string          `json:"location"`
	Formatid                     int32           `json:"formatid"`
	Leagueid                     sql.NullInt32   `json:"leagueid"`
	Coordinatorid                int32           `json:"coordinatorid"`
	Numberofpreliminaryrounds    int32           `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds    int32           `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary   int32           `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination   int32           `json:"judgesperdebateelimination"`
	Tournamentfee                string          `json:"tournamentfee"`
	Imageurl                     sql.NullString  `json:"imageurl"`
	CreatedAt                    sql.NullTime    `json:"created_at"`
	UpdatedAt                    sql.NullTime    `json:"updated_at"`
	DeletedAt                    sql.NullTime    `json:"deleted_at"`
	YesterdayTotalCount          sql.NullInt32   `json:"yesterday_total_count"`
	YesterdayUpcomingCount       sql.NullInt32   `json:"yesterday_upcoming_count"`
	YesterdayActiveDebatersCount sql.NullInt32   `json:"yesterday_active_debaters_count"`
	Formatname                   string          `json:"formatname"`
	Formatdescription            sql.NullString  `json:"formatdescription"`
	Speakersperteam              int32           `json:"speakersperteam"`
	Leaguename                   string          `json:"leaguename"`
	Leaguetype                   string          `json:"leaguetype"`
	Leaguedetails                json.RawMessage `json:"leaguedetails"`
	Coordinatorname              string          `json:"coordinatorname"`
	Coordinatorid_2              int32           `json:"coordinatorid_2"`
}

func (q *Queries) GetTournamentByID(ctx context.Context, tournamentid int32) (GetTournamentByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTournamentByID, tournamentid)
	var i GetTournamentByIDRow
	err := row.Scan(
		&i.Tournamentid,
		&i.Name,
		&i.Startdate,
		&i.Enddate,
		&i.Location,
		&i.Formatid,
		&i.Leagueid,
		&i.Coordinatorid,
		&i.Numberofpreliminaryrounds,
		&i.Numberofeliminationrounds,
		&i.Judgesperdebatepreliminary,
		&i.Judgesperdebateelimination,
		&i.Tournamentfee,
		&i.Imageurl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
		&i.YesterdayActiveDebatersCount,
		&i.Formatname,
		&i.Formatdescription,
		&i.Speakersperteam,
		&i.Leaguename,
		&i.Leaguetype,
		&i.Leaguedetails,
		&i.Coordinatorname,
		&i.Coordinatorid_2,
	)
	return i, err
}

const getTournamentExpenses = `-- name: GetTournamentExpenses :one
SELECT expenseid, tournamentid, foodexpense, transportexpense, perdiemexpense, awardingexpense, stationaryexpense, otherexpenses, totalexpense, currency, notes, createdat, updatedat, createdby, updatedby FROM TournamentExpenses
WHERE TournamentID = $1
`

func (q *Queries) GetTournamentExpenses(ctx context.Context, tournamentid int32) (Tournamentexpense, error) {
	row := q.db.QueryRowContext(ctx, getTournamentExpenses, tournamentid)
	var i Tournamentexpense
	err := row.Scan(
		&i.Expenseid,
		&i.Tournamentid,
		&i.Foodexpense,
		&i.Transportexpense,
		&i.Perdiemexpense,
		&i.Awardingexpense,
		&i.Stationaryexpense,
		&i.Otherexpenses,
		&i.Totalexpense,
		&i.Currency,
		&i.Notes,
		&i.Createdat,
		&i.Updatedat,
		&i.Createdby,
		&i.Updatedby,
	)
	return i, err
}

const getTournamentFormatByID = `-- name: GetTournamentFormatByID :one
SELECT formatid, formatname, description, speakersperteam, deleted_at FROM TournamentFormats
WHERE FormatID = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTournamentFormatByID(ctx context.Context, formatid int32) (Tournamentformat, error) {
	row := q.db.QueryRowContext(ctx, getTournamentFormatByID, formatid)
	var i Tournamentformat
	err := row.Scan(
		&i.Formatid,
		&i.Formatname,
		&i.Description,
		&i.Speakersperteam,
		&i.DeletedAt,
	)
	return i, err
}

const getTournamentRegistrations = `-- name: GetTournamentRegistrations :many
SELECT
    DATE(ti.updated_at) AS registration_date,
    COUNT(*) AS registration_count
FROM
    TournamentInvitations ti
WHERE
    ti.Status = 'accepted'
GROUP BY
    DATE(ti.updated_at)
ORDER BY
    registration_date DESC
LIMIT 30
`

type GetTournamentRegistrationsRow struct {
	RegistrationDate  time.Time `json:"registration_date"`
	RegistrationCount int64     `json:"registration_count"`
}

func (q *Queries) GetTournamentRegistrations(ctx context.Context) ([]GetTournamentRegistrationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentRegistrationsRow{}
	for rows.Next() {
		var i GetTournamentRegistrationsRow
		if err := rows.Scan(&i.RegistrationDate, &i.RegistrationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentStats = `-- name: GetTournamentStats :one

WITH CurrentStats AS (
    SELECT
        COUNT(*) AS total_tournaments,
        COUNT(CASE WHEN StartDate BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' THEN 1 END) AS upcoming_tournaments
    FROM Tournaments
    WHERE deleted_at IS NULL
),
HistoricalStats AS (
    SELECT
        yesterday_total_count,
        yesterday_upcoming_count,
        yesterday_active_debaters_count
    FROM Tournaments
    WHERE TournamentID = (SELECT MIN(TournamentID) FROM Tournaments)
),
SchoolDebaters AS (
    SELECT COUNT(DISTINCT tm.StudentID) as active_debater_count
    FROM TeamMembers tm
    JOIN Teams t ON tm.TeamID = t.TeamID
    JOIN Students s ON tm.StudentID = s.StudentID
    JOIN Tournaments tour ON t.TournamentID = tour.TournamentID
    WHERE s.SchoolID = $2
      AND tour.deleted_at IS NULL
)
SELECT
    cs.total_tournaments,
    cs.upcoming_tournaments,
    hs.yesterday_total_count,
    hs.yesterday_upcoming_count,
    CASE
        WHEN $1 = 'admin' THEN 0
        ELSE COALESCE(sd.active_debater_count, 0)
    END as active_debater_count,
    CASE
        WHEN $1 = 'admin' THEN 0
        ELSE COALESCE(hs.yesterday_active_debaters_count, 0)
    END as yesterday_active_debaters_count
FROM CurrentStats cs, HistoricalStats hs
LEFT JOIN SchoolDebaters sd ON true
WHERE ($1 = 'admin' OR $2 IS NOT NULL)
`

type GetTournamentStatsParams struct {
	UserRole interface{} `json:"user_role"`
	SchoolID interface{} `json:"school_id"`
}

type GetTournamentStatsRow struct {
	TotalTournaments             int64         `json:"total_tournaments"`
	UpcomingTournaments          int64         `json:"upcoming_tournaments"`
	YesterdayTotalCount          sql.NullInt32 `json:"yesterday_total_count"`
	YesterdayUpcomingCount       sql.NullInt32 `json:"yesterday_upcoming_count"`
	ActiveDebaterCount           interface{}   `json:"active_debater_count"`
	YesterdayActiveDebatersCount interface{}   `json:"yesterday_active_debaters_count"`
}

// Limiting to last 30 days, adjust as needed
func (q *Queries) GetTournamentStats(ctx context.Context, arg GetTournamentStatsParams) (GetTournamentStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTournamentStats, arg.UserRole, arg.SchoolID)
	var i GetTournamentStatsRow
	err := row.Scan(
		&i.TotalTournaments,
		&i.UpcomingTournaments,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
		&i.ActiveDebaterCount,
		&i.YesterdayActiveDebatersCount,
	)
	return i, err
}

const listLeaguesPaginated = `-- name: ListLeaguesPaginated :many
SELECT leagueid, name, leaguetype, details, deleted_at FROM Leagues
WHERE deleted_at IS NULL
ORDER BY LeagueID
LIMIT $1 OFFSET $2
`

type ListLeaguesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLeaguesPaginated(ctx context.Context, arg ListLeaguesPaginatedParams) ([]League, error) {
	rows, err := q.db.QueryContext(ctx, listLeaguesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.Leagueid,
			&i.Name,
			&i.Leaguetype,
			&i.Details,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentFormatsPaginated = `-- name: ListTournamentFormatsPaginated :many
SELECT formatid, formatname, description, speakersperteam, deleted_at FROM TournamentFormats
WHERE deleted_at IS NULL
ORDER BY FormatID
LIMIT $1 OFFSET $2
`

type ListTournamentFormatsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTournamentFormatsPaginated(ctx context.Context, arg ListTournamentFormatsPaginatedParams) ([]Tournamentformat, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentFormatsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournamentformat{}
	for rows.Next() {
		var i Tournamentformat
		if err := rows.Scan(
			&i.Formatid,
			&i.Formatname,
			&i.Description,
			&i.Speakersperteam,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentRegistrations = `-- name: ListTournamentRegistrations :many
SELECT
    str.registrationid, str.schoolid, str.tournamentid, str.plannedteamscount, str.actualteamscount, str.amountperteam, str.totalamount, str.discountamount, str.actualpaidamount, str.paymentstatus, str.paymentdate, str.currency, str.createdat, str.updatedat, str.createdby, str.updatedby,
    s.iDebateSchoolID,
    s.SchoolName,
    s.SchoolEmail,
    s.SchoolID
FROM SchoolTournamentRegistrations str
JOIN Schools s ON str.SchoolID = s.SchoolID
WHERE str.TournamentID = $1
ORDER BY str.CreatedAt DESC
LIMIT $2 OFFSET $3
`

type ListTournamentRegistrationsParams struct {
	Tournamentid int32 `json:"tournamentid"`
	Limit        int32 `json:"limit"`
	Offset       int32 `json:"offset"`
}

type ListTournamentRegistrationsRow struct {
	Registrationid    int32          `json:"registrationid"`
	Schoolid          int32          `json:"schoolid"`
	Tournamentid      int32          `json:"tournamentid"`
	Plannedteamscount int32          `json:"plannedteamscount"`
	Actualteamscount  sql.NullInt32  `json:"actualteamscount"`
	Amountperteam     string         `json:"amountperteam"`
	Totalamount       sql.NullString `json:"totalamount"`
	Discountamount    sql.NullString `json:"discountamount"`
	Actualpaidamount  sql.NullString `json:"actualpaidamount"`
	Paymentstatus     string         `json:"paymentstatus"`
	Paymentdate       sql.NullTime   `json:"paymentdate"`
	Currency          string         `json:"currency"`
	Createdat         sql.NullTime   `json:"createdat"`
	Updatedat         sql.NullTime   `json:"updatedat"`
	Createdby         sql.NullInt32  `json:"createdby"`
	Updatedby         sql.NullInt32  `json:"updatedby"`
	Idebateschoolid   sql.NullString `json:"idebateschoolid"`
	Schoolname        string         `json:"schoolname"`
	Schoolemail       string         `json:"schoolemail"`
	Schoolid_2        int32          `json:"schoolid_2"`
}

func (q *Queries) ListTournamentRegistrations(ctx context.Context, arg ListTournamentRegistrationsParams) ([]ListTournamentRegistrationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentRegistrations, arg.Tournamentid, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTournamentRegistrationsRow{}
	for rows.Next() {
		var i ListTournamentRegistrationsRow
		if err := rows.Scan(
			&i.Registrationid,
			&i.Schoolid,
			&i.Tournamentid,
			&i.Plannedteamscount,
			&i.Actualteamscount,
			&i.Amountperteam,
			&i.Totalamount,
			&i.Discountamount,
			&i.Actualpaidamount,
			&i.Paymentstatus,
			&i.Paymentdate,
			&i.Currency,
			&i.Createdat,
			&i.Updatedat,
			&i.Createdby,
			&i.Updatedby,
			&i.Idebateschoolid,
			&i.Schoolname,
			&i.Schoolemail,
			&i.Schoolid_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentsPaginated = `-- name: ListTournamentsPaginated :many
SELECT
    t.tournamentid, t.name, t.startdate, t.enddate, t.location, t.formatid, t.leagueid, t.coordinatorid, t.numberofpreliminaryrounds, t.numberofeliminationrounds, t.judgesperdebatepreliminary, t.judgesperdebateelimination, t.tournamentfee, t.imageurl, t.created_at, t.updated_at, t.deleted_at, t.yesterday_total_count, t.yesterday_upcoming_count, t.yesterday_active_debaters_count,
    tf.FormatName,
    l.Name AS LeagueName,
    u.Name AS CoordinatorName,
    u.UserID AS CoordinatorID,
    COUNT(DISTINCT CASE WHEN ti.InviteeRole = 'school' AND ti.Status = 'accepted' THEN ti.InvitationID END) AS AcceptedSchoolsCount,
    COUNT(DISTINCT tm.TeamID) AS TeamsCount
FROM
    Tournaments t
JOIN
    TournamentFormats tf ON t.FormatID = tf.FormatID
JOIN
    Leagues l ON t.LeagueID = l.LeagueID
JOIN
    Users u ON t.CoordinatorID = u.UserID
LEFT JOIN
    TournamentInvitations ti ON t.TournamentID = ti.TournamentID
LEFT JOIN
    Teams tm ON t.TournamentID = tm.TournamentID
WHERE
    t.deleted_at IS NULL
GROUP BY
    t.TournamentID, tf.FormatName, l.Name, u.Name, u.UserID
ORDER BY
    t.StartDate DESC
LIMIT $1 OFFSET $2
`

type ListTournamentsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListTournamentsPaginatedRow struct {
	Tournamentid                 int32          `json:"tournamentid"`
	Name                         string         `json:"name"`
	Startdate                    time.Time      `json:"startdate"`
	Enddate                      time.Time      `json:"enddate"`
	Location                     string         `json:"location"`
	Formatid                     int32          `json:"formatid"`
	Leagueid                     sql.NullInt32  `json:"leagueid"`
	Coordinatorid                int32          `json:"coordinatorid"`
	Numberofpreliminaryrounds    int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds    int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary   int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination   int32          `json:"judgesperdebateelimination"`
	Tournamentfee                string         `json:"tournamentfee"`
	Imageurl                     sql.NullString `json:"imageurl"`
	CreatedAt                    sql.NullTime   `json:"created_at"`
	UpdatedAt                    sql.NullTime   `json:"updated_at"`
	DeletedAt                    sql.NullTime   `json:"deleted_at"`
	YesterdayTotalCount          sql.NullInt32  `json:"yesterday_total_count"`
	YesterdayUpcomingCount       sql.NullInt32  `json:"yesterday_upcoming_count"`
	YesterdayActiveDebatersCount sql.NullInt32  `json:"yesterday_active_debaters_count"`
	Formatname                   string         `json:"formatname"`
	Leaguename                   string         `json:"leaguename"`
	Coordinatorname              string         `json:"coordinatorname"`
	Coordinatorid_2              int32          `json:"coordinatorid_2"`
	Acceptedschoolscount         int64          `json:"acceptedschoolscount"`
	Teamscount                   int64          `json:"teamscount"`
}

func (q *Queries) ListTournamentsPaginated(ctx context.Context, arg ListTournamentsPaginatedParams) ([]ListTournamentsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTournamentsPaginatedRow{}
	for rows.Next() {
		var i ListTournamentsPaginatedRow
		if err := rows.Scan(
			&i.Tournamentid,
			&i.Name,
			&i.Startdate,
			&i.Enddate,
			&i.Location,
			&i.Formatid,
			&i.Leagueid,
			&i.Coordinatorid,
			&i.Numberofpreliminaryrounds,
			&i.Numberofeliminationrounds,
			&i.Judgesperdebatepreliminary,
			&i.Judgesperdebateelimination,
			&i.Tournamentfee,
			&i.Imageurl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.YesterdayTotalCount,
			&i.YesterdayUpcomingCount,
			&i.YesterdayActiveDebatersCount,
			&i.Formatname,
			&i.Leaguename,
			&i.Coordinatorname,
			&i.Coordinatorid_2,
			&i.Acceptedschoolscount,
			&i.Teamscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTournaments = `-- name: SearchTournaments :many
SELECT TournamentID, Name
FROM Tournaments
WHERE LOWER(Name) LIKE LOWER($1)
  AND deleted_at IS NULL
ORDER BY Name
LIMIT 10
`

type SearchTournamentsRow struct {
	Tournamentid int32  `json:"tournamentid"`
	Name         string `json:"name"`
}

func (q *Queries) SearchTournaments(ctx context.Context, lower string) ([]SearchTournamentsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchTournaments, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchTournamentsRow{}
	for rows.Next() {
		var i SearchTournamentsRow
		if err := rows.Scan(&i.Tournamentid, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :one
UPDATE TournamentInvitations
SET Status = $2, updated_at = CURRENT_TIMESTAMP
WHERE InvitationID = $1
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type UpdateInvitationStatusParams struct {
	Invitationid int32  `json:"invitationid"`
	Status       string `json:"status"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, updateInvitationStatus, arg.Invitationid, arg.Status)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const updateLeague = `-- name: UpdateLeague :one
UPDATE Leagues
SET Name = $2, LeagueType = $3, Details = $4
WHERE LeagueID = $1
RETURNING leagueid, name, leaguetype, details, deleted_at
`

type UpdateLeagueParams struct {
	Leagueid   int32           `json:"leagueid"`
	Name       string          `json:"name"`
	Leaguetype string          `json:"leaguetype"`
	Details    json.RawMessage `json:"details"`
}

func (q *Queries) UpdateLeague(ctx context.Context, arg UpdateLeagueParams) (League, error) {
	row := q.db.QueryRowContext(ctx, updateLeague,
		arg.Leagueid,
		arg.Name,
		arg.Leaguetype,
		arg.Details,
	)
	var i League
	err := row.Scan(
		&i.Leagueid,
		&i.Name,
		&i.Leaguetype,
		&i.Details,
		&i.DeletedAt,
	)
	return i, err
}

const updateReminderSentAt = `-- name: UpdateReminderSentAt :one
UPDATE TournamentInvitations
SET ReminderSentAt = $2
WHERE InvitationID = $1
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type UpdateReminderSentAtParams struct {
	Invitationid   int32        `json:"invitationid"`
	Remindersentat sql.NullTime `json:"remindersentat"`
}

func (q *Queries) UpdateReminderSentAt(ctx context.Context, arg UpdateReminderSentAtParams) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, updateReminderSentAt, arg.Invitationid, arg.Remindersentat)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const updateSchoolRegistration = `-- name: UpdateSchoolRegistration :one
UPDATE SchoolTournamentRegistrations
SET
    ActualTeamsCount = $3,
    DiscountAmount = $4,
    ActualPaidAmount = $5,
    PaymentStatus = $6,
    PaymentDate = CASE
        WHEN $8::text = 'paid' THEN CURRENT_TIMESTAMP
        ELSE PaymentDate
    END,
    UpdatedBy = $7,
    UpdatedAt = CURRENT_TIMESTAMP
WHERE SchoolID = $1 AND TournamentID = $2
RETURNING registrationid, schoolid, tournamentid, plannedteamscount, actualteamscount, amountperteam, totalamount, discountamount, actualpaidamount, paymentstatus, paymentdate, currency, createdat, updatedat, createdby, updatedby
`

type UpdateSchoolRegistrationParams struct {
	Schoolid         int32          `json:"schoolid"`
	Tournamentid     int32          `json:"tournamentid"`
	Actualteamscount sql.NullInt32  `json:"actualteamscount"`
	Discountamount   sql.NullString `json:"discountamount"`
	Actualpaidamount sql.NullString `json:"actualpaidamount"`
	Paymentstatus    string         `json:"paymentstatus"`
	Updatedby        sql.NullInt32  `json:"updatedby"`
	Column8          string         `json:"column_8"`
}

func (q *Queries) UpdateSchoolRegistration(ctx context.Context, arg UpdateSchoolRegistrationParams) (Schooltournamentregistration, error) {
	row := q.db.QueryRowContext(ctx, updateSchoolRegistration,
		arg.Schoolid,
		arg.Tournamentid,
		arg.Actualteamscount,
		arg.Discountamount,
		arg.Actualpaidamount,
		arg.Paymentstatus,
		arg.Updatedby,
		arg.Column8,
	)
	var i Schooltournamentregistration
	err := row.Scan(
		&i.Registrationid,
		&i.Schoolid,
		&i.Tournamentid,
		&i.Plannedteamscount,
		&i.Actualteamscount,
		&i.Amountperteam,
		&i.Totalamount,
		&i.Discountamount,
		&i.Actualpaidamount,
		&i.Paymentstatus,
		&i.Paymentdate,
		&i.Currency,
		&i.Createdat,
		&i.Updatedat,
		&i.Createdby,
		&i.Updatedby,
	)
	return i, err
}

const updateTournamentDetails = `-- name: UpdateTournamentDetails :one
WITH debate_check AS (
    SELECT EXISTS (
        SELECT 1
        FROM Debates
        WHERE TournamentID = $1
    ) AS has_debates
)
UPDATE Tournaments t
SET Name = $2,
    StartDate = $3,
    EndDate = $4,
    Location = $5,
    FormatID = $6,
    LeagueID = $7,
    NumberOfPreliminaryRounds = $8,
    NumberOfEliminationRounds = $9,
    JudgesPerDebatePreliminary = $10,
    JudgesPerDebateElimination = $11,
    TournamentFee = $12,
    ImageUrl = $13
FROM debate_check
WHERE t.TournamentID = $1
  AND NOT debate_check.has_debates
RETURNING t.tournamentid, t.name, t.startdate, t.enddate, t.location, t.formatid, t.leagueid, t.coordinatorid, t.numberofpreliminaryrounds, t.numberofeliminationrounds, t.judgesperdebatepreliminary, t.judgesperdebateelimination, t.tournamentfee, t.imageurl, t.created_at, t.updated_at, t.deleted_at, t.yesterday_total_count, t.yesterday_upcoming_count, t.yesterday_active_debaters_count,
    CASE
        WHEN debate_check.has_debates THEN 'Cannot update: Debates exist'::text
        ELSE NULL
    END AS error_message
`

type UpdateTournamentDetailsParams struct {
	Tournamentid               int32          `json:"tournamentid"`
	Name                       string         `json:"name"`
	Startdate                  time.Time      `json:"startdate"`
	Enddate                    time.Time      `json:"enddate"`
	Location                   string         `json:"location"`
	Formatid                   int32          `json:"formatid"`
	Leagueid                   sql.NullInt32  `json:"leagueid"`
	Numberofpreliminaryrounds  int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32          `json:"judgesperdebateelimination"`
	Tournamentfee              string         `json:"tournamentfee"`
	Imageurl                   sql.NullString `json:"imageurl"`
}

type UpdateTournamentDetailsRow struct {
	Tournamentid                 int32          `json:"tournamentid"`
	Name                         string         `json:"name"`
	Startdate                    time.Time      `json:"startdate"`
	Enddate                      time.Time      `json:"enddate"`
	Location                     string         `json:"location"`
	Formatid                     int32          `json:"formatid"`
	Leagueid                     sql.NullInt32  `json:"leagueid"`
	Coordinatorid                int32          `json:"coordinatorid"`
	Numberofpreliminaryrounds    int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds    int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary   int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination   int32          `json:"judgesperdebateelimination"`
	Tournamentfee                string         `json:"tournamentfee"`
	Imageurl                     sql.NullString `json:"imageurl"`
	CreatedAt                    sql.NullTime   `json:"created_at"`
	UpdatedAt                    sql.NullTime   `json:"updated_at"`
	DeletedAt                    sql.NullTime   `json:"deleted_at"`
	YesterdayTotalCount          sql.NullInt32  `json:"yesterday_total_count"`
	YesterdayUpcomingCount       sql.NullInt32  `json:"yesterday_upcoming_count"`
	YesterdayActiveDebatersCount sql.NullInt32  `json:"yesterday_active_debaters_count"`
	ErrorMessage                 interface{}    `json:"error_message"`
}

func (q *Queries) UpdateTournamentDetails(ctx context.Context, arg UpdateTournamentDetailsParams) (UpdateTournamentDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentDetails,
		arg.Tournamentid,
		arg.Name,
		arg.Startdate,
		arg.Enddate,
		arg.Location,
		arg.Formatid,
		arg.Leagueid,
		arg.Numberofpreliminaryrounds,
		arg.Numberofeliminationrounds,
		arg.Judgesperdebatepreliminary,
		arg.Judgesperdebateelimination,
		arg.Tournamentfee,
		arg.Imageurl,
	)
	var i UpdateTournamentDetailsRow
	err := row.Scan(
		&i.Tournamentid,
		&i.Name,
		&i.Startdate,
		&i.Enddate,
		&i.Location,
		&i.Formatid,
		&i.Leagueid,
		&i.Coordinatorid,
		&i.Numberofpreliminaryrounds,
		&i.Numberofeliminationrounds,
		&i.Judgesperdebatepreliminary,
		&i.Judgesperdebateelimination,
		&i.Tournamentfee,
		&i.Imageurl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
		&i.YesterdayActiveDebatersCount,
		&i.ErrorMessage,
	)
	return i, err
}

const updateTournamentExpenses = `-- name: UpdateTournamentExpenses :one
UPDATE TournamentExpenses
SET
    FoodExpense = $2,
    TransportExpense = $3,
    PerDiemExpense = $4,
    AwardingExpense = $5,
    StationaryExpense = $6,
    OtherExpenses = $7,
    Currency = $8,
    Notes = $9,
    UpdatedBy = $10
WHERE TournamentID = $1
RETURNING expenseid, tournamentid, foodexpense, transportexpense, perdiemexpense, awardingexpense, stationaryexpense, otherexpenses, totalexpense, currency, notes, createdat, updatedat, createdby, updatedby
`

type UpdateTournamentExpensesParams struct {
	Tournamentid      int32          `json:"tournamentid"`
	Foodexpense       string         `json:"foodexpense"`
	Transportexpense  string         `json:"transportexpense"`
	Perdiemexpense    string         `json:"perdiemexpense"`
	Awardingexpense   string         `json:"awardingexpense"`
	Stationaryexpense string         `json:"stationaryexpense"`
	Otherexpenses     string         `json:"otherexpenses"`
	Currency          string         `json:"currency"`
	Notes             sql.NullString `json:"notes"`
	Updatedby         sql.NullInt32  `json:"updatedby"`
}

func (q *Queries) UpdateTournamentExpenses(ctx context.Context, arg UpdateTournamentExpensesParams) (Tournamentexpense, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentExpenses,
		arg.Tournamentid,
		arg.Foodexpense,
		arg.Transportexpense,
		arg.Perdiemexpense,
		arg.Awardingexpense,
		arg.Stationaryexpense,
		arg.Otherexpenses,
		arg.Currency,
		arg.Notes,
		arg.Updatedby,
	)
	var i Tournamentexpense
	err := row.Scan(
		&i.Expenseid,
		&i.Tournamentid,
		&i.Foodexpense,
		&i.Transportexpense,
		&i.Perdiemexpense,
		&i.Awardingexpense,
		&i.Stationaryexpense,
		&i.Otherexpenses,
		&i.Totalexpense,
		&i.Currency,
		&i.Notes,
		&i.Createdat,
		&i.Updatedat,
		&i.Createdby,
		&i.Updatedby,
	)
	return i, err
}

const updateTournamentFormatDetails = `-- name: UpdateTournamentFormatDetails :one
UPDATE TournamentFormats
SET FormatName = $2, Description = $3, SpeakersPerTeam = $4
WHERE FormatID = $1
RETURNING formatid, formatname, description, speakersperteam, deleted_at
`

type UpdateTournamentFormatDetailsParams struct {
	Formatid        int32          `json:"formatid"`
	Formatname      string         `json:"formatname"`
	Description     sql.NullString `json:"description"`
	Speakersperteam int32          `json:"speakersperteam"`
}

func (q *Queries) UpdateTournamentFormatDetails(ctx context.Context, arg UpdateTournamentFormatDetailsParams) (Tournamentformat, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentFormatDetails,
		arg.Formatid,
		arg.Formatname,
		arg.Description,
		arg.Speakersperteam,
	)
	var i Tournamentformat
	err := row.Scan(
		&i.Formatid,
		&i.Formatname,
		&i.Description,
		&i.Speakersperteam,
		&i.DeletedAt,
	)
	return i, err
}
