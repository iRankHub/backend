// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: tournament.sql

package models

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const bulkUpdateInvitationStatus = `-- name: BulkUpdateInvitationStatus :many
UPDATE TournamentInvitations
SET Status = $2, updated_at = CURRENT_TIMESTAMP
WHERE InvitationID = ANY($1::int[])
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type BulkUpdateInvitationStatusParams struct {
	Column1 []int32 `json:"column_1"`
	Status  string  `json:"status"`
}

func (q *Queries) BulkUpdateInvitationStatus(ctx context.Context, arg BulkUpdateInvitationStatusParams) ([]Tournamentinvitation, error) {
	rows, err := q.db.QueryContext(ctx, bulkUpdateInvitationStatus, pq.Array(arg.Column1), arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournamentinvitation{}
	for rows.Next() {
		var i Tournamentinvitation
		if err := rows.Scan(
			&i.Invitationid,
			&i.Tournamentid,
			&i.Inviteeid,
			&i.Inviteerole,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Remindersentat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createInvitation = `-- name: CreateInvitation :one
INSERT INTO TournamentInvitations (TournamentID, InviteeID, InviteeRole, Status)
VALUES ($1, $2, $3, $4)
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type CreateInvitationParams struct {
	Tournamentid int32  `json:"tournamentid"`
	Inviteeid    string `json:"inviteeid"`
	Inviteerole  string `json:"inviteerole"`
	Status       string `json:"status"`
}

func (q *Queries) CreateInvitation(ctx context.Context, arg CreateInvitationParams) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, createInvitation,
		arg.Tournamentid,
		arg.Inviteeid,
		arg.Inviteerole,
		arg.Status,
	)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const createLeague = `-- name: CreateLeague :one
INSERT INTO Leagues (Name, LeagueType, Details)
VALUES ($1, $2, $3)
RETURNING leagueid, name, leaguetype, details, deleted_at
`

type CreateLeagueParams struct {
	Name       string          `json:"name"`
	Leaguetype string          `json:"leaguetype"`
	Details    json.RawMessage `json:"details"`
}

// League Queries
func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.db.QueryRowContext(ctx, createLeague, arg.Name, arg.Leaguetype, arg.Details)
	var i League
	err := row.Scan(
		&i.Leagueid,
		&i.Name,
		&i.Leaguetype,
		&i.Details,
		&i.DeletedAt,
	)
	return i, err
}

const createTournamentEntry = `-- name: CreateTournamentEntry :one
INSERT INTO Tournaments (Name, StartDate, EndDate, Location, FormatID, LeagueID, CoordinatorID, NumberOfPreliminaryRounds, NumberOfEliminationRounds, JudgesPerDebatePreliminary, JudgesPerDebateElimination, TournamentFee, ImageUrl)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING tournamentid, name, startdate, enddate, location, formatid, leagueid, coordinatorid, numberofpreliminaryrounds, numberofeliminationrounds, judgesperdebatepreliminary, judgesperdebateelimination, tournamentfee, imageurl, created_at, updated_at, deleted_at, yesterday_total_count, yesterday_upcoming_count
`

type CreateTournamentEntryParams struct {
	Name                       string         `json:"name"`
	Startdate                  time.Time      `json:"startdate"`
	Enddate                    time.Time      `json:"enddate"`
	Location                   string         `json:"location"`
	Formatid                   int32          `json:"formatid"`
	Leagueid                   sql.NullInt32  `json:"leagueid"`
	Coordinatorid              int32          `json:"coordinatorid"`
	Numberofpreliminaryrounds  int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32          `json:"judgesperdebateelimination"`
	Tournamentfee              string         `json:"tournamentfee"`
	Imageurl                   sql.NullString `json:"imageurl"`
}

// Tournament Queries
func (q *Queries) CreateTournamentEntry(ctx context.Context, arg CreateTournamentEntryParams) (Tournament, error) {
	row := q.db.QueryRowContext(ctx, createTournamentEntry,
		arg.Name,
		arg.Startdate,
		arg.Enddate,
		arg.Location,
		arg.Formatid,
		arg.Leagueid,
		arg.Coordinatorid,
		arg.Numberofpreliminaryrounds,
		arg.Numberofeliminationrounds,
		arg.Judgesperdebatepreliminary,
		arg.Judgesperdebateelimination,
		arg.Tournamentfee,
		arg.Imageurl,
	)
	var i Tournament
	err := row.Scan(
		&i.Tournamentid,
		&i.Name,
		&i.Startdate,
		&i.Enddate,
		&i.Location,
		&i.Formatid,
		&i.Leagueid,
		&i.Coordinatorid,
		&i.Numberofpreliminaryrounds,
		&i.Numberofeliminationrounds,
		&i.Judgesperdebatepreliminary,
		&i.Judgesperdebateelimination,
		&i.Tournamentfee,
		&i.Imageurl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
	)
	return i, err
}

const createTournamentFormat = `-- name: CreateTournamentFormat :one
INSERT INTO TournamentFormats (FormatName, Description, SpeakersPerTeam)
VALUES ($1, $2, $3)
RETURNING formatid, formatname, description, speakersperteam, deleted_at
`

type CreateTournamentFormatParams struct {
	Formatname      string         `json:"formatname"`
	Description     sql.NullString `json:"description"`
	Speakersperteam int32          `json:"speakersperteam"`
}

// Tournament Format Queries
func (q *Queries) CreateTournamentFormat(ctx context.Context, arg CreateTournamentFormatParams) (Tournamentformat, error) {
	row := q.db.QueryRowContext(ctx, createTournamentFormat, arg.Formatname, arg.Description, arg.Speakersperteam)
	var i Tournamentformat
	err := row.Scan(
		&i.Formatid,
		&i.Formatname,
		&i.Description,
		&i.Speakersperteam,
		&i.DeletedAt,
	)
	return i, err
}

const deleteInvitation = `-- name: DeleteInvitation :exec
DELETE FROM TournamentInvitations WHERE InvitationID = $1
`

func (q *Queries) DeleteInvitation(ctx context.Context, invitationid int32) error {
	_, err := q.db.ExecContext(ctx, deleteInvitation, invitationid)
	return err
}

const deleteLeagueByID = `-- name: DeleteLeagueByID :exec
UPDATE Leagues
SET deleted_at = CURRENT_TIMESTAMP
WHERE LeagueID = $1
`

func (q *Queries) DeleteLeagueByID(ctx context.Context, leagueid int32) error {
	_, err := q.db.ExecContext(ctx, deleteLeagueByID, leagueid)
	return err
}

const deleteTournamentByID = `-- name: DeleteTournamentByID :exec
UPDATE Tournaments
SET deleted_at = CURRENT_TIMESTAMP
WHERE TournamentID = $1
`

func (q *Queries) DeleteTournamentByID(ctx context.Context, tournamentid int32) error {
	_, err := q.db.ExecContext(ctx, deleteTournamentByID, tournamentid)
	return err
}

const deleteTournamentFormatByID = `-- name: DeleteTournamentFormatByID :exec
UPDATE TournamentFormats
SET deleted_at = CURRENT_TIMESTAMP
WHERE FormatID = $1
`

func (q *Queries) DeleteTournamentFormatByID(ctx context.Context, formatid int32) error {
	_, err := q.db.ExecContext(ctx, deleteTournamentFormatByID, formatid)
	return err
}

const getActiveTournaments = `-- name: GetActiveTournaments :many
SELECT tournamentid, name, startdate, enddate, location, formatid, leagueid, coordinatorid, numberofpreliminaryrounds, numberofeliminationrounds, judgesperdebatepreliminary, judgesperdebateelimination, tournamentfee, imageurl, created_at, updated_at, deleted_at, yesterday_total_count, yesterday_upcoming_count FROM Tournaments
WHERE StartDate > CURRENT_TIMESTAMP
  AND deleted_at IS NULL
ORDER BY StartDate
`

func (q *Queries) GetActiveTournaments(ctx context.Context) ([]Tournament, error) {
	rows, err := q.db.QueryContext(ctx, getActiveTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournament{}
	for rows.Next() {
		var i Tournament
		if err := rows.Scan(
			&i.Tournamentid,
			&i.Name,
			&i.Startdate,
			&i.Enddate,
			&i.Location,
			&i.Formatid,
			&i.Leagueid,
			&i.Coordinatorid,
			&i.Numberofpreliminaryrounds,
			&i.Numberofeliminationrounds,
			&i.Judgesperdebatepreliminary,
			&i.Judgesperdebateelimination,
			&i.Tournamentfee,
			&i.Imageurl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.YesterdayTotalCount,
			&i.YesterdayUpcomingCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationByID = `-- name: GetInvitationByID :one
SELECT invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat FROM TournamentInvitations WHERE InvitationID = $1
`

func (q *Queries) GetInvitationByID(ctx context.Context, invitationid int32) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, getInvitationByID, invitationid)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const getInvitationsByTournament = `-- name: GetInvitationsByTournament :many
SELECT
    ti.InvitationID,
    ti.Status,
    ti.InviteeID,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.SchoolName
        WHEN ti.InviteeRole = 'volunteer' THEN CONCAT(v.FirstName, ' ', v.LastName)
        WHEN ti.InviteeRole = 'student' THEN CONCAT(st.FirstName, ' ', st.LastName)
    END as InviteeName,
    ti.InviteeRole,
    ti.created_at,
    ti.updated_at
FROM
    TournamentInvitations ti
LEFT JOIN
    Schools s ON ti.InviteeID = s.iDebateSchoolID
LEFT JOIN
    Volunteers v ON ti.InviteeID = v.iDebateVolunteerID
LEFT JOIN
    Students st ON ti.InviteeID = st.iDebateStudentID
WHERE
    ti.TournamentID = $1
ORDER BY
    ti.created_at DESC
`

type GetInvitationsByTournamentRow struct {
	Invitationid int32        `json:"invitationid"`
	Status       string       `json:"status"`
	Inviteeid    string       `json:"inviteeid"`
	Inviteename  interface{}  `json:"inviteename"`
	Inviteerole  string       `json:"inviteerole"`
	CreatedAt    sql.NullTime `json:"created_at"`
	UpdatedAt    sql.NullTime `json:"updated_at"`
}

func (q *Queries) GetInvitationsByTournament(ctx context.Context, tournamentid int32) ([]GetInvitationsByTournamentRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByTournament, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByTournamentRow{}
	for rows.Next() {
		var i GetInvitationsByTournamentRow
		if err := rows.Scan(
			&i.Invitationid,
			&i.Status,
			&i.Inviteeid,
			&i.Inviteename,
			&i.Inviteerole,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInvitationsByUser = `-- name: GetInvitationsByUser :many
SELECT
    ti.invitationid, ti.tournamentid, ti.inviteeid, ti.inviteerole, ti.status, ti.created_at, ti.updated_at, ti.remindersentat,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.SchoolName
        WHEN ti.InviteeRole = 'volunteer' THEN CONCAT(v.FirstName, ' ', v.LastName)
        WHEN ti.InviteeRole = 'student' THEN CONCAT(st.FirstName, ' ', st.LastName)
    END AS InviteeName
FROM TournamentInvitations ti
LEFT JOIN Schools s ON ti.InviteeRole = 'school' AND ti.InviteeID = s.iDebateSchoolID
LEFT JOIN Volunteers v ON ti.InviteeRole = 'volunteer' AND ti.InviteeID = v.iDebateVolunteerID
LEFT JOIN Students st ON ti.InviteeRole = 'student' AND ti.InviteeID = st.iDebateStudentID
WHERE
    (ti.InviteeRole = 'school' AND s.ContactPersonID = $1) OR
    (ti.InviteeRole = 'volunteer' AND v.UserID = $1) OR
    (ti.InviteeRole = 'student' AND st.UserID = $1)
ORDER BY ti.created_at DESC
`

type GetInvitationsByUserRow struct {
	Invitationid   int32        `json:"invitationid"`
	Tournamentid   int32        `json:"tournamentid"`
	Inviteeid      string       `json:"inviteeid"`
	Inviteerole    string       `json:"inviteerole"`
	Status         string       `json:"status"`
	CreatedAt      sql.NullTime `json:"created_at"`
	UpdatedAt      sql.NullTime `json:"updated_at"`
	Remindersentat sql.NullTime `json:"remindersentat"`
	Inviteename    interface{}  `json:"inviteename"`
}

func (q *Queries) GetInvitationsByUser(ctx context.Context, contactpersonid int32) ([]GetInvitationsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getInvitationsByUser, contactpersonid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetInvitationsByUserRow{}
	for rows.Next() {
		var i GetInvitationsByUserRow
		if err := rows.Scan(
			&i.Invitationid,
			&i.Tournamentid,
			&i.Inviteeid,
			&i.Inviteerole,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Remindersentat,
			&i.Inviteename,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueByID = `-- name: GetLeagueByID :one
SELECT leagueid, name, leaguetype, details, deleted_at FROM Leagues
WHERE LeagueID = $1 AND deleted_at IS NULL
`

func (q *Queries) GetLeagueByID(ctx context.Context, leagueid int32) (League, error) {
	row := q.db.QueryRowContext(ctx, getLeagueByID, leagueid)
	var i League
	err := row.Scan(
		&i.Leagueid,
		&i.Name,
		&i.Leaguetype,
		&i.Details,
		&i.DeletedAt,
	)
	return i, err
}

const getPendingInvitations = `-- name: GetPendingInvitations :many
SELECT
    ti.invitationid, ti.tournamentid, ti.inviteeid, ti.inviteerole, ti.status, ti.created_at, ti.updated_at, ti.remindersentat,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.SchoolName
        WHEN ti.InviteeRole = 'volunteer' THEN CONCAT(v.FirstName, ' ', v.LastName)
        WHEN ti.InviteeRole = 'student' THEN CONCAT(st.FirstName, ' ', st.LastName)
    END as InviteeName,
    CASE
        WHEN ti.InviteeRole = 'school' THEN s.ContactEmail
        WHEN ti.InviteeRole = 'volunteer' THEN u.Email
        WHEN ti.InviteeRole = 'student' THEN st.Email
    END as InviteeEmail,
    t.Name as TournamentName,
    t.StartDate as TournamentStartDate,
    t.EndDate as TournamentEndDate,
    t.Location as TournamentLocation
FROM
    TournamentInvitations ti
JOIN
    Tournaments t ON ti.TournamentID = t.TournamentID
LEFT JOIN
    Schools s ON ti.InviteeRole = 'school' AND ti.InviteeID = s.iDebateSchoolID
LEFT JOIN
    Volunteers v ON ti.InviteeRole = 'volunteer' AND ti.InviteeID = v.iDebateVolunteerID
LEFT JOIN
    Students st ON ti.InviteeRole = 'student' AND ti.InviteeID = st.iDebateStudentID
LEFT JOIN
    Users u ON (ti.InviteeRole = 'volunteer' AND v.UserID = u.UserID)
WHERE
    ti.TournamentID = $1 AND ti.Status = 'pending'
ORDER BY
    ti.created_at DESC
`

type GetPendingInvitationsRow struct {
	Invitationid        int32        `json:"invitationid"`
	Tournamentid        int32        `json:"tournamentid"`
	Inviteeid           string       `json:"inviteeid"`
	Inviteerole         string       `json:"inviteerole"`
	Status              string       `json:"status"`
	CreatedAt           sql.NullTime `json:"created_at"`
	UpdatedAt           sql.NullTime `json:"updated_at"`
	Remindersentat      sql.NullTime `json:"remindersentat"`
	Inviteename         interface{}  `json:"inviteename"`
	Inviteeemail        interface{}  `json:"inviteeemail"`
	Tournamentname      string       `json:"tournamentname"`
	Tournamentstartdate time.Time    `json:"tournamentstartdate"`
	Tournamentenddate   time.Time    `json:"tournamentenddate"`
	Tournamentlocation  string       `json:"tournamentlocation"`
}

func (q *Queries) GetPendingInvitations(ctx context.Context, tournamentid int32) ([]GetPendingInvitationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingInvitations, tournamentid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingInvitationsRow{}
	for rows.Next() {
		var i GetPendingInvitationsRow
		if err := rows.Scan(
			&i.Invitationid,
			&i.Tournamentid,
			&i.Inviteeid,
			&i.Inviteerole,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Remindersentat,
			&i.Inviteename,
			&i.Inviteeemail,
			&i.Tournamentname,
			&i.Tournamentstartdate,
			&i.Tournamentenddate,
			&i.Tournamentlocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentByID = `-- name: GetTournamentByID :one
SELECT t.tournamentid, t.name, t.startdate, t.enddate, t.location, t.formatid, t.leagueid, t.coordinatorid, t.numberofpreliminaryrounds, t.numberofeliminationrounds, t.judgesperdebatepreliminary, t.judgesperdebateelimination, t.tournamentfee, t.imageurl, t.created_at, t.updated_at, t.deleted_at, t.yesterday_total_count, t.yesterday_upcoming_count, tf.FormatName, tf.Description AS FormatDescription, tf.SpeakersPerTeam,
       l.Name AS LeagueName, l.LeagueType, l.Details AS LeagueDetails,
       u.Name AS CoordinatorName, u.UserID AS CoordinatorID
FROM Tournaments t
JOIN TournamentFormats tf ON t.FormatID = tf.FormatID
JOIN Leagues l ON t.LeagueID = l.LeagueID
JOIN Users u ON t.CoordinatorID = u.UserID
WHERE t.TournamentID = $1 AND t.deleted_at IS NULL
`

type GetTournamentByIDRow struct {
	Tournamentid               int32           `json:"tournamentid"`
	Name                       string          `json:"name"`
	Startdate                  time.Time       `json:"startdate"`
	Enddate                    time.Time       `json:"enddate"`
	Location                   string          `json:"location"`
	Formatid                   int32           `json:"formatid"`
	Leagueid                   sql.NullInt32   `json:"leagueid"`
	Coordinatorid              int32           `json:"coordinatorid"`
	Numberofpreliminaryrounds  int32           `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32           `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32           `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32           `json:"judgesperdebateelimination"`
	Tournamentfee              string          `json:"tournamentfee"`
	Imageurl                   sql.NullString  `json:"imageurl"`
	CreatedAt                  sql.NullTime    `json:"created_at"`
	UpdatedAt                  sql.NullTime    `json:"updated_at"`
	DeletedAt                  sql.NullTime    `json:"deleted_at"`
	YesterdayTotalCount        sql.NullInt32   `json:"yesterday_total_count"`
	YesterdayUpcomingCount     sql.NullInt32   `json:"yesterday_upcoming_count"`
	Formatname                 string          `json:"formatname"`
	Formatdescription          sql.NullString  `json:"formatdescription"`
	Speakersperteam            int32           `json:"speakersperteam"`
	Leaguename                 string          `json:"leaguename"`
	Leaguetype                 string          `json:"leaguetype"`
	Leaguedetails              json.RawMessage `json:"leaguedetails"`
	Coordinatorname            string          `json:"coordinatorname"`
	Coordinatorid_2            int32           `json:"coordinatorid_2"`
}

func (q *Queries) GetTournamentByID(ctx context.Context, tournamentid int32) (GetTournamentByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTournamentByID, tournamentid)
	var i GetTournamentByIDRow
	err := row.Scan(
		&i.Tournamentid,
		&i.Name,
		&i.Startdate,
		&i.Enddate,
		&i.Location,
		&i.Formatid,
		&i.Leagueid,
		&i.Coordinatorid,
		&i.Numberofpreliminaryrounds,
		&i.Numberofeliminationrounds,
		&i.Judgesperdebatepreliminary,
		&i.Judgesperdebateelimination,
		&i.Tournamentfee,
		&i.Imageurl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
		&i.Formatname,
		&i.Formatdescription,
		&i.Speakersperteam,
		&i.Leaguename,
		&i.Leaguetype,
		&i.Leaguedetails,
		&i.Coordinatorname,
		&i.Coordinatorid_2,
	)
	return i, err
}

const getTournamentFormatByID = `-- name: GetTournamentFormatByID :one
SELECT formatid, formatname, description, speakersperteam, deleted_at FROM TournamentFormats
WHERE FormatID = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTournamentFormatByID(ctx context.Context, formatid int32) (Tournamentformat, error) {
	row := q.db.QueryRowContext(ctx, getTournamentFormatByID, formatid)
	var i Tournamentformat
	err := row.Scan(
		&i.Formatid,
		&i.Formatname,
		&i.Description,
		&i.Speakersperteam,
		&i.DeletedAt,
	)
	return i, err
}

const getTournamentRegistrations = `-- name: GetTournamentRegistrations :many
SELECT
    DATE(ti.updated_at) AS registration_date,
    COUNT(*) AS registration_count
FROM
    TournamentInvitations ti
WHERE
    ti.Status = 'accepted'
GROUP BY
    DATE(ti.updated_at)
ORDER BY
    registration_date DESC
LIMIT 30
`

type GetTournamentRegistrationsRow struct {
	RegistrationDate  time.Time `json:"registration_date"`
	RegistrationCount int64     `json:"registration_count"`
}

func (q *Queries) GetTournamentRegistrations(ctx context.Context) ([]GetTournamentRegistrationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTournamentRegistrations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTournamentRegistrationsRow{}
	for rows.Next() {
		var i GetTournamentRegistrationsRow
		if err := rows.Scan(&i.RegistrationDate, &i.RegistrationCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentStats = `-- name: GetTournamentStats :one

WITH CurrentStats AS (
    SELECT
        COUNT(*) AS total_tournaments,
        COUNT(CASE WHEN StartDate BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '30 days' THEN 1 END) AS upcoming_tournaments
    FROM Tournaments
    WHERE deleted_at IS NULL
),
HistoricalStats AS (
    SELECT yesterday_total_count, yesterday_upcoming_count
    FROM Tournaments
    WHERE TournamentID = (SELECT MIN(TournamentID) FROM Tournaments)
)
SELECT
    cs.total_tournaments,
    cs.upcoming_tournaments,
    hs.yesterday_total_count,
    hs.yesterday_upcoming_count
FROM CurrentStats cs, HistoricalStats hs
`

type GetTournamentStatsRow struct {
	TotalTournaments       int64         `json:"total_tournaments"`
	UpcomingTournaments    int64         `json:"upcoming_tournaments"`
	YesterdayTotalCount    sql.NullInt32 `json:"yesterday_total_count"`
	YesterdayUpcomingCount sql.NullInt32 `json:"yesterday_upcoming_count"`
}

// Limiting to last 30 days, adjust as needed
func (q *Queries) GetTournamentStats(ctx context.Context) (GetTournamentStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getTournamentStats)
	var i GetTournamentStatsRow
	err := row.Scan(
		&i.TotalTournaments,
		&i.UpcomingTournaments,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
	)
	return i, err
}

const listLeaguesPaginated = `-- name: ListLeaguesPaginated :many
SELECT leagueid, name, leaguetype, details, deleted_at FROM Leagues
WHERE deleted_at IS NULL
ORDER BY LeagueID
LIMIT $1 OFFSET $2
`

type ListLeaguesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLeaguesPaginated(ctx context.Context, arg ListLeaguesPaginatedParams) ([]League, error) {
	rows, err := q.db.QueryContext(ctx, listLeaguesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []League{}
	for rows.Next() {
		var i League
		if err := rows.Scan(
			&i.Leagueid,
			&i.Name,
			&i.Leaguetype,
			&i.Details,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentFormatsPaginated = `-- name: ListTournamentFormatsPaginated :many
SELECT formatid, formatname, description, speakersperteam, deleted_at FROM TournamentFormats
WHERE deleted_at IS NULL
ORDER BY FormatID
LIMIT $1 OFFSET $2
`

type ListTournamentFormatsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTournamentFormatsPaginated(ctx context.Context, arg ListTournamentFormatsPaginatedParams) ([]Tournamentformat, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentFormatsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tournamentformat{}
	for rows.Next() {
		var i Tournamentformat
		if err := rows.Scan(
			&i.Formatid,
			&i.Formatname,
			&i.Description,
			&i.Speakersperteam,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTournamentsPaginated = `-- name: ListTournamentsPaginated :many
SELECT
    t.tournamentid, t.name, t.startdate, t.enddate, t.location, t.formatid, t.leagueid, t.coordinatorid, t.numberofpreliminaryrounds, t.numberofeliminationrounds, t.judgesperdebatepreliminary, t.judgesperdebateelimination, t.tournamentfee, t.imageurl, t.created_at, t.updated_at, t.deleted_at, t.yesterday_total_count, t.yesterday_upcoming_count,
    tf.FormatName,
    l.Name AS LeagueName,
    u.Name AS CoordinatorName,
    u.UserID AS CoordinatorID,
    COUNT(DISTINCT CASE WHEN ti.InviteeRole = 'school' AND ti.Status = 'accepted' THEN ti.InvitationID END) AS AcceptedSchoolsCount,
    COUNT(DISTINCT tm.TeamID) AS TeamsCount
FROM
    Tournaments t
JOIN
    TournamentFormats tf ON t.FormatID = tf.FormatID
JOIN
    Leagues l ON t.LeagueID = l.LeagueID
JOIN
    Users u ON t.CoordinatorID = u.UserID
LEFT JOIN
    TournamentInvitations ti ON t.TournamentID = ti.TournamentID
LEFT JOIN
    Teams tm ON t.TournamentID = tm.TournamentID
WHERE
    t.deleted_at IS NULL
GROUP BY
    t.TournamentID, tf.FormatName, l.Name, u.Name, u.UserID
ORDER BY
    t.StartDate DESC
LIMIT $1 OFFSET $2
`

type ListTournamentsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListTournamentsPaginatedRow struct {
	Tournamentid               int32          `json:"tournamentid"`
	Name                       string         `json:"name"`
	Startdate                  time.Time      `json:"startdate"`
	Enddate                    time.Time      `json:"enddate"`
	Location                   string         `json:"location"`
	Formatid                   int32          `json:"formatid"`
	Leagueid                   sql.NullInt32  `json:"leagueid"`
	Coordinatorid              int32          `json:"coordinatorid"`
	Numberofpreliminaryrounds  int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32          `json:"judgesperdebateelimination"`
	Tournamentfee              string         `json:"tournamentfee"`
	Imageurl                   sql.NullString `json:"imageurl"`
	CreatedAt                  sql.NullTime   `json:"created_at"`
	UpdatedAt                  sql.NullTime   `json:"updated_at"`
	DeletedAt                  sql.NullTime   `json:"deleted_at"`
	YesterdayTotalCount        sql.NullInt32  `json:"yesterday_total_count"`
	YesterdayUpcomingCount     sql.NullInt32  `json:"yesterday_upcoming_count"`
	Formatname                 string         `json:"formatname"`
	Leaguename                 string         `json:"leaguename"`
	Coordinatorname            string         `json:"coordinatorname"`
	Coordinatorid_2            int32          `json:"coordinatorid_2"`
	Acceptedschoolscount       int64          `json:"acceptedschoolscount"`
	Teamscount                 int64          `json:"teamscount"`
}

func (q *Queries) ListTournamentsPaginated(ctx context.Context, arg ListTournamentsPaginatedParams) ([]ListTournamentsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, listTournamentsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTournamentsPaginatedRow{}
	for rows.Next() {
		var i ListTournamentsPaginatedRow
		if err := rows.Scan(
			&i.Tournamentid,
			&i.Name,
			&i.Startdate,
			&i.Enddate,
			&i.Location,
			&i.Formatid,
			&i.Leagueid,
			&i.Coordinatorid,
			&i.Numberofpreliminaryrounds,
			&i.Numberofeliminationrounds,
			&i.Judgesperdebatepreliminary,
			&i.Judgesperdebateelimination,
			&i.Tournamentfee,
			&i.Imageurl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.YesterdayTotalCount,
			&i.YesterdayUpcomingCount,
			&i.Formatname,
			&i.Leaguename,
			&i.Coordinatorname,
			&i.Coordinatorid_2,
			&i.Acceptedschoolscount,
			&i.Teamscount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvitationStatus = `-- name: UpdateInvitationStatus :one
UPDATE TournamentInvitations
SET Status = $2, updated_at = CURRENT_TIMESTAMP
WHERE InvitationID = $1
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type UpdateInvitationStatusParams struct {
	Invitationid int32  `json:"invitationid"`
	Status       string `json:"status"`
}

func (q *Queries) UpdateInvitationStatus(ctx context.Context, arg UpdateInvitationStatusParams) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, updateInvitationStatus, arg.Invitationid, arg.Status)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const updateLeague = `-- name: UpdateLeague :one
UPDATE Leagues
SET Name = $2, LeagueType = $3, Details = $4
WHERE LeagueID = $1
RETURNING leagueid, name, leaguetype, details, deleted_at
`

type UpdateLeagueParams struct {
	Leagueid   int32           `json:"leagueid"`
	Name       string          `json:"name"`
	Leaguetype string          `json:"leaguetype"`
	Details    json.RawMessage `json:"details"`
}

func (q *Queries) UpdateLeague(ctx context.Context, arg UpdateLeagueParams) (League, error) {
	row := q.db.QueryRowContext(ctx, updateLeague,
		arg.Leagueid,
		arg.Name,
		arg.Leaguetype,
		arg.Details,
	)
	var i League
	err := row.Scan(
		&i.Leagueid,
		&i.Name,
		&i.Leaguetype,
		&i.Details,
		&i.DeletedAt,
	)
	return i, err
}

const updateReminderSentAt = `-- name: UpdateReminderSentAt :one
UPDATE TournamentInvitations
SET ReminderSentAt = $2
WHERE InvitationID = $1
RETURNING invitationid, tournamentid, inviteeid, inviteerole, status, created_at, updated_at, remindersentat
`

type UpdateReminderSentAtParams struct {
	Invitationid   int32        `json:"invitationid"`
	Remindersentat sql.NullTime `json:"remindersentat"`
}

func (q *Queries) UpdateReminderSentAt(ctx context.Context, arg UpdateReminderSentAtParams) (Tournamentinvitation, error) {
	row := q.db.QueryRowContext(ctx, updateReminderSentAt, arg.Invitationid, arg.Remindersentat)
	var i Tournamentinvitation
	err := row.Scan(
		&i.Invitationid,
		&i.Tournamentid,
		&i.Inviteeid,
		&i.Inviteerole,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Remindersentat,
	)
	return i, err
}

const updateTournamentDetails = `-- name: UpdateTournamentDetails :one
WITH debate_check AS (
    SELECT EXISTS (
        SELECT 1
        FROM Debates
        WHERE TournamentID = $1
    ) AS has_debates
)
UPDATE Tournaments t
SET Name = $2,
    StartDate = $3,
    EndDate = $4,
    Location = $5,
    FormatID = $6,
    LeagueID = $7,
    NumberOfPreliminaryRounds = $8,
    NumberOfEliminationRounds = $9,
    JudgesPerDebatePreliminary = $10,
    JudgesPerDebateElimination = $11,
    TournamentFee = $12,
    ImageUrl = $13
FROM debate_check
WHERE t.TournamentID = $1
  AND NOT debate_check.has_debates
RETURNING t.tournamentid, t.name, t.startdate, t.enddate, t.location, t.formatid, t.leagueid, t.coordinatorid, t.numberofpreliminaryrounds, t.numberofeliminationrounds, t.judgesperdebatepreliminary, t.judgesperdebateelimination, t.tournamentfee, t.imageurl, t.created_at, t.updated_at, t.deleted_at, t.yesterday_total_count, t.yesterday_upcoming_count,
    CASE
        WHEN debate_check.has_debates THEN 'Cannot update: Debates exist'::text
        ELSE NULL
    END AS error_message
`

type UpdateTournamentDetailsParams struct {
	Tournamentid               int32          `json:"tournamentid"`
	Name                       string         `json:"name"`
	Startdate                  time.Time      `json:"startdate"`
	Enddate                    time.Time      `json:"enddate"`
	Location                   string         `json:"location"`
	Formatid                   int32          `json:"formatid"`
	Leagueid                   sql.NullInt32  `json:"leagueid"`
	Numberofpreliminaryrounds  int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32          `json:"judgesperdebateelimination"`
	Tournamentfee              string         `json:"tournamentfee"`
	Imageurl                   sql.NullString `json:"imageurl"`
}

type UpdateTournamentDetailsRow struct {
	Tournamentid               int32          `json:"tournamentid"`
	Name                       string         `json:"name"`
	Startdate                  time.Time      `json:"startdate"`
	Enddate                    time.Time      `json:"enddate"`
	Location                   string         `json:"location"`
	Formatid                   int32          `json:"formatid"`
	Leagueid                   sql.NullInt32  `json:"leagueid"`
	Coordinatorid              int32          `json:"coordinatorid"`
	Numberofpreliminaryrounds  int32          `json:"numberofpreliminaryrounds"`
	Numberofeliminationrounds  int32          `json:"numberofeliminationrounds"`
	Judgesperdebatepreliminary int32          `json:"judgesperdebatepreliminary"`
	Judgesperdebateelimination int32          `json:"judgesperdebateelimination"`
	Tournamentfee              string         `json:"tournamentfee"`
	Imageurl                   sql.NullString `json:"imageurl"`
	CreatedAt                  sql.NullTime   `json:"created_at"`
	UpdatedAt                  sql.NullTime   `json:"updated_at"`
	DeletedAt                  sql.NullTime   `json:"deleted_at"`
	YesterdayTotalCount        sql.NullInt32  `json:"yesterday_total_count"`
	YesterdayUpcomingCount     sql.NullInt32  `json:"yesterday_upcoming_count"`
	ErrorMessage               interface{}    `json:"error_message"`
}

func (q *Queries) UpdateTournamentDetails(ctx context.Context, arg UpdateTournamentDetailsParams) (UpdateTournamentDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentDetails,
		arg.Tournamentid,
		arg.Name,
		arg.Startdate,
		arg.Enddate,
		arg.Location,
		arg.Formatid,
		arg.Leagueid,
		arg.Numberofpreliminaryrounds,
		arg.Numberofeliminationrounds,
		arg.Judgesperdebatepreliminary,
		arg.Judgesperdebateelimination,
		arg.Tournamentfee,
		arg.Imageurl,
	)
	var i UpdateTournamentDetailsRow
	err := row.Scan(
		&i.Tournamentid,
		&i.Name,
		&i.Startdate,
		&i.Enddate,
		&i.Location,
		&i.Formatid,
		&i.Leagueid,
		&i.Coordinatorid,
		&i.Numberofpreliminaryrounds,
		&i.Numberofeliminationrounds,
		&i.Judgesperdebatepreliminary,
		&i.Judgesperdebateelimination,
		&i.Tournamentfee,
		&i.Imageurl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.YesterdayTotalCount,
		&i.YesterdayUpcomingCount,
		&i.ErrorMessage,
	)
	return i, err
}

const updateTournamentFormatDetails = `-- name: UpdateTournamentFormatDetails :one
UPDATE TournamentFormats
SET FormatName = $2, Description = $3, SpeakersPerTeam = $4
WHERE FormatID = $1
RETURNING formatid, formatname, description, speakersperteam, deleted_at
`

type UpdateTournamentFormatDetailsParams struct {
	Formatid        int32          `json:"formatid"`
	Formatname      string         `json:"formatname"`
	Description     sql.NullString `json:"description"`
	Speakersperteam int32          `json:"speakersperteam"`
}

func (q *Queries) UpdateTournamentFormatDetails(ctx context.Context, arg UpdateTournamentFormatDetailsParams) (Tournamentformat, error) {
	row := q.db.QueryRowContext(ctx, updateTournamentFormatDetails,
		arg.Formatid,
		arg.Formatname,
		arg.Description,
		arg.Speakersperteam,
	)
	var i Tournamentformat
	err := row.Scan(
		&i.Formatid,
		&i.Formatname,
		&i.Description,
		&i.Speakersperteam,
		&i.DeletedAt,
	)
	return i, err
}
